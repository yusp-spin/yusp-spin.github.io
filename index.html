<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>如果方向错误，停止前进就是一种进步</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">如果方向错误，停止前进就是一种进步</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/tags/%E6%97%A5%E5%B8%B8/">杂谈</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ZGC入门介绍" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/21/ZGC%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time class="dt-published" datetime="2022-08-21T12:23:01.000Z" itemprop="datePublished">2022-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/21/ZGC%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">ZGC简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>java11介绍了一个优秀的垃圾回收实现ZGC，ZGC是一款以低延迟为首要目标、基于paper内存布局、不设分代的并发垃圾收集器。</p>
<p>相比于其他垃圾回收器，ZGC有着不同的特点：</p>
<ol>
<li><p>低时延，在垃圾回收过程中，只有与root有关的处理才会STW，时延不是随着堆大小而增加，低时延是最大的特点，也是ZGC的设计目标</p>
</li>
<li><p>内存分区管理</p>
<p>支持不同的分区粒度，有小页面、中页面、大页面之分。</p>
</li>
<li><p>不分代的垃圾回收</p>
<p>在标记阶段，对全量内存进行标记，在回收的时候，选择回收价值更大的页面</p>
</li>
<li><p>Colored Pointer，在引用上利用标记位来表示对象不同的状态，并利用多视图映射将不同的虚拟地址映射岛同一物理地址</p>
</li>
<li><p>使用Load-Barrier，来完成并发标记和并发重定位</p>
</li>
<li><p>支持NUMA，进来把对象分配在访问速度比较快的地方</p>
</li>
</ol>
<h4 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h4><p>ZGC的内存管理和G1类似，使用分区管理。在G1中，一个分区称为一个region，大小是固定的。在ZGC中分区叫做page，分为小、中、大</p>
<h4 id="3-ZGC流程"><a href="#3-ZGC流程" class="headerlink" title="3. ZGC流程"></a>3. ZGC流程</h4><p>ZGC回收流程包括6个阶段，可分为标记和重定位两个过程</p>
<p>标记的方法很多种，1. 弄个map，key为对象地址，value为对象状态；2. 在对象头，记录对象状态。3. ZGC采用的是 对引用进行标记，把对象状态，记录在引用的几个bit上，即“Colored Pointer”</p>
<h4 id="4-标记过程"><a href="#4-标记过程" class="headerlink" title="4. 标记过程"></a>4. 标记过程</h4><ol>
<li>开始标记，STW，这个阶段，GC线程完成对根引用的标记，由于跟引用数量通常很少，所以这个阶段很短</li>
<li>并发标记，GC线程从根引用开始深度优先遍历对象图，标记达到的每一个对象。工作线程的Load-Barrier检测到未标记的引用时，也会标记。还会对上一次GC中没有完成重映射的引用，进行重映射，即Remap。</li>
<li>结束标记，也是STW的。处理一些边缘情况，比如弱引用，这个阶段很快，时间较短</li>
</ol>
<p>标记过程中，除了使用“Colored Pointer”进行标记外，针对每一个page还会使用liveMap记录page里哪些对象时活得，以及所占空间，为下一个阶段中 选择合适回收page和存活对象重定位做准备。</p>
<p>指针表示一个字节在虚拟内存中的具体地址，我们42位表示指针的地址，4位来表示这个指针的一些属性（Finalizable，Remapped，Marked，Marked）用于ZGC标记</p>
<ul>
<li>Finalizable标记只能通过终结器访问对象</li>
<li>Remapped 表示这个引用是最新的，只想对象的当前位置。在load-barrier中，完成重映射后，会设置为Remapped</li>
<li>Marked0和Marked1 标记可访问的对象，在ZGC标记过程中，使用这两交替访问‘</li>
</ul>
<p>ZGC使用42位表示地址，所以ZGC支持堆内存最大位4TB，JDK15中，扩展到了16T</p>
<h4 id="5-重定位过程"><a href="#5-重定位过程" class="headerlink" title="5. 重定位过程"></a>5. 重定位过程</h4><h4 id="6-重映射过程"><a href="#6-重映射过程" class="headerlink" title="6. 重映射过程"></a>6. 重映射过程</h4><h4 id="7-Load-Barrier"><a href="#7-Load-Barrier" class="headerlink" title="7. Load-Barrier"></a>7. Load-Barrier</h4><h4 id="8-并发标记过程详解"><a href="#8-并发标记过程详解" class="headerlink" title="8. 并发标记过程详解"></a>8. 并发标记过程详解</h4><h4 id="9-并发重定位-amp-重映射过程详解"><a href="#9-并发重定位-amp-重映射过程详解" class="headerlink" title="9. 并发重定位&amp;重映射过程详解"></a>9. 并发重定位&amp;重映射过程详解</h4><h4 id="10-如何进行页面回收的选择"><a href="#10-如何进行页面回收的选择" class="headerlink" title="10. 如何进行页面回收的选择"></a>10. 如何进行页面回收的选择</h4><h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2022/08/21/ZGC%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/" data-id="cl73fb6w70013rou94o6pa8ig" data-title="ZGC简介" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Kafka消费者消费消息(高级API)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/04/10/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF(%E9%AB%98%E7%BA%A7API)/" class="article-date">
  <time class="dt-published" datetime="2022-04-10T10:51:12.000Z" itemprop="datePublished">2022-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/04/10/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF(%E9%AB%98%E7%BA%A7API)/">Kafka消费者消费消息(高级API)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>Kafka消费者有三种API，Scala实现的两种消费者API 叫做高级API和低级API，新版本的消费者采用Java重新实现叫做 新API。 但不管采用什么版本实现，消费者消费消息的主要工作没有太大变化 ， 比如为消费者分配分区、拉取线程拉取消息客户端消费消息、更新拉取状态、提交偏移量 。  本文介绍内容主要是高级API</p>
<p>消费者拉取钱程拉取每个分区的数据，会将分区的消息集包装成一个数据块，放入分区信息的队列中 。 而每个队列都对应一个消息流，消费者客户端选代消息流，实际上是迭代每个数据块中消息集的每条消息 。<br>如图所示，一个队列包含多个数据块，每个数据块对应一个分区的消息集， 一个消息集包含<br>多条消息 。 消费者迭代器封装了迭代获取消息的逻辑，客户端不需要面向数据<br>块、消息集这些内部对象，只需要对消费者迭代器循环获取消息即可 。  </p>
<p><img src="https://yusp-spin.github.io/photo/kafka-consumer.png" alt="kafka消费者消费流程"></p>
<h4 id="二、消费者迭代消费消息"><a href="#二、消费者迭代消费消息" class="headerlink" title="二、消费者迭代消费消息"></a>二、消费者迭代消费消息</h4><p>​    消费者迭代器生成包含消息的迭代器，首先弹出队列的每个数据块，然后获取数据块对应的消息集，最后迭代消息集中的每条消息 。 客户端迭代的消息是队列的所有数据块，而不是一个数据块。 所以在迭代过程中，要确保读取完一个数据块后，接着读取下一个数据块。 也就是说，消费者迭代器是：所有数据块通过消息集组成的消息迭代器  。</p>
<p>​    消费者迭代器实现了 Java的 Iterator接口，必须重载hasNext ()和 next()方法。 hasNext ()方法会用来判断迭代器是杏结束， next ()方法每调用一次就指向迭代器的下一个元素 。 迭代的过程因为最上层数据结构是包含数据块的阻塞队列，所以从队列中弹出一个数据块就已经足够调用很多次next()了 。只有当前数据块的消息集都遍历完成后，才会从队列中弹出新的数据块  </p>
<p>​    在迭代的过程中，可能 多 次调用 next()方法都还是在同一数据块的同一个消息集 中， 所以迭代器妥保存当前的数据块、当前的 消息集。 如果当前消息 集没有下一个元素，则 需要同时更新这两个变量 。 因为一个数据块对应一个消息集 ，一旦当前消息集没有元素 了， 说明 这个数据块也．已经迭代完毕。  </p>
<h4 id="三、偏移量"><a href="#三、偏移量" class="headerlink" title="三、偏移量"></a>三、偏移量</h4><h5 id="3-1-两种偏移量"><a href="#3-1-两种偏移量" class="headerlink" title="3.1 两种偏移量"></a>3.1 两种偏移量</h5><p>消费者的“拉取线程” 拉取消息后会更新“拉取状态 ” ，对应的 “消费线程”获取消息后也要更新相关的“消费状态” 。 （准确地说，消费消息的对象是一个迭代器而不是钱程。 这里为了和拉取线程相对应，故叫作消费线程。  拉取状态对应分区信息、对象的拉取偏移量 ， 表示消费者已经拉取的分区位置 ； 消费状态对应了消费偏移量，表示消费者已经消费完成的偏移量 。<br>如 图 3-23所示 ， 拉取消息的线程和消费消息 的线程是两个独立的工作模块，前者通过分区信息对象的阻塞队列将消息传给消费消息的线程完成数据的传输 。 消息拉取后只有被消费线程真正消后，才会更新消费状态 。 也就是说，“拉取线程更新拉取偏移量，消费线程更新消费偏移量”，</p>
<p>具体步骤如下 :<br>(1） 消费者 的拉取线程从服务端拉取分区 的消息 。<br>(2）拉取到分区消息后 ，就更新分区信息对象的拉取偏移量 。<br>(3）将分区数据的消 息集封装成数据块 。<br>(4） 客户端循环迭代数据块的消息集 。<br>(5） 消费完一条消息后，就更新分区信息对象的消费偏移量<br>(6）消息流中的每一条消息返回给消费者客户端应用程序 。</p>
<p><img src="https://yusp-spin.github.io/photo/kafka-offset.png" alt="拉取线程和消费线程分别更新分区信息的状态"></p>
<h5 id="3-2-提交偏移量"><a href="#3-2-提交偏移量" class="headerlink" title="3.2 提交偏移量"></a>3.2 提交偏移量</h5><p>在旧版本中每个分区的偏移量都保存到ZK中  ，分区信息的拉取偏移初始时从ZK读取，然后在拉取消息后更新 。 同样，消费偏移盘初始时也是从ZK读取，然后在消费消息后更新。 消费者消费了新的消息后，还应该及时地将消费进度（即分区信息的消费偏移盘）保存到ZK中 。  每个分区都要和ZK产生一次交互，况且还要周期性地写人，这对ZK来说是个不小的负担。 在新版本中把偏移量像普通消息一样写入Kafka集群的内部主题。 而且正像消息会源源不断地写到集群一样，记录偏移量也是周期性的 。 Kafka支持高吞吐量的消息写入，对于偏移量的记录当然也不在话下 。  </p>
<p>消费者提交偏移量是为了保存分区的消费进度 。 因为Kafka保证同一个分区只会分配给消费组中的唯一消费者，所以即使发生再平衡后，分区和消费者的所有权关系发生变化，新消费者也可以接着上一个消费者记录的偏移盘位置继续消费消息 。<br>但是消费者即使记录了分区的偏移量，仍然无法解决消息被重复消费的问题。 例如，消费者每隔 10秒提交一次偏移量，在 10秒时提交的偏移量是 100 ，下一次提交的可点是20秒。 在20秒之前，消费者又消费了 30条消息，然后消费者突然挂掉了 。 由于偏移量现在仍然停留在 10。这个位置，因此新的消费者2也只会从 10。这个位置继续消费，从而会重复处理偏移量为 100之后的30条消息 。通常消息被重复处理是可以接受的，至少不会出现消息丢失这种不可接受的问题。 定时提交偏移量的周期时间越长，消息被重复消费的数据量就越多。 客户端可以将这个周期时间设置得更短，来减少重复消费的消息量。 当然也不能太短，否则会导致客户端和保存偏移量的存储系统产生大量的网请求 。  </p>
<p>消费者提交偏移量到Kafka的 内部主题，首先要确定连接哪个或者哪些服务端节点 。 回顾一下 ，<br>生产者发送消息时会根据分区的主副本分组 ， 和多个节点者建立连接 ； 消费者分配多个分区 ，也要根<br>据分区的主副本分组， 和多个节点建立连接。 而消费者提交所有分区 的偏移量时， 实际上只和－个服<br>务端节点建立连接。 同样要处理多个分区，为什么普通消息需要多个连接，而偏移量只需要一个连接？<br>如图 3-24所示，目标节点指的是分区的主副本节点，我们给 出 了偏移量的多种连接方案 。<br>(1）如果不同分区的偏移盐写到了不同的节点，消费者分配了多个分区，当要读取不同分区的偏<br>移盘时，就得连接不同的节点才可以获得完整的数据。<br>(2）如果能让所有分区的偏移草’数据只保存在一个节点，消费者就只需要 同一个节点通信 。 但因<br>为消费者和分区的关系是变化的， 即使保证这一次分区在一个节点上， 也无法保证下一次仍然在同一<br>个节点 。<br>(3）如果消费组所有消费者所有分区的偏移量都保存在一个节点，就可以解决第二种方式的 问题 。</p>
<p>实际上 ， 消费者 的分区偏移盏’要保存在哪个节点，跟消费者所属 的消费组有关系 。 只要保证<br>消费组级别的偏移i量在一个节点上， 即使消费者和分区的关系发生变化 ， 也能够保证消费者访问新分<br>配的分区时 ， 只需要访问一个节点 。  </p>
<p>同一个消费组的所有消费者，以内部主题形式提交所有分区的偏移盘到一个目标节点，这个内部主题和普通消息的主题一样也会有多个分区。 如果只有一个分区 ，所有消费组都只能提交到唯一的节点，将所有读写请求都压到一个节点的相同问题。 而如果有多个分区，并且以消费组作为分区的分布条件，不同消费组提交到的偏移量有可能是不同的节点，就可以分散偏移盘读写的压力 。  </p>
<p>总结下客户端需要确定服务端节点的几个场景。  </p>
<ul>
<li>生产者发送消息时，直接在客户端决定消息要发送给哪个分区，这一步不向服务端发送请求 。</li>
<li>消费者拉取管理器的线程向服务端发送主题元数据请求，获取包含了主副本等信息的所有分区元数据，消费者拉取线程才能确定要连接哪些服务端节点 。</li>
<li>提交偏移量虽然有点像生产者的发送消息，都是写数据，但也需要和消费者一样，获取分区的主副本作为偏移管理器，才能确定提交到哪个节点 。  </li>
</ul>
<p><img src="https://yusp-spin.github.io/photo/kafka-connect.png" alt="生产者、消费者、偏移量和Kafka集群的网络连接  "></p>
<h4 id="四、连接偏移管理器"><a href="#四、连接偏移管理器" class="headerlink" title="四、连接偏移管理器"></a>四、连接偏移管理器</h4><p>前面我们分析的拉取偏移方法和提交偏移量方法，都需要和偏移主－管理器通信。 在这之前，消费者需要通过 channelToOffsetManage （）方法向服务端任意一个节点发送“消费组的协调者请求”，来获取消费组对应的协调节点 ，即偏移量管理器节点 。服务端处理消费组的协调者请求，实际上也是通过查询主题的元数据来完成的 。 不过和 中返回主题元数据，然后还要在客户端继续处理（ 比如获取存在主副本的分区）不同，这里在服务端完成“选择消费组对应内部主题的分区的主副本节点”，然后直接返回这个协调节点给客户端。 也就是说客户端发送消费组的协调者请求，服务端返回的就是消费组的协调节点 。 </p>
<h4 id="五、服务端处理提交偏移量的请求"><a href="#五、服务端处理提交偏移量的请求" class="headerlink" title="五、服务端处理提交偏移量的请求"></a>五、服务端处理提交偏移量的请求</h4><p>协调节点会将消费者的偏移量提交请GroupCoordlnator类的 handleCommitOffsets ()方法处理，其中参数offsetMetadata表示分配给消费者的所有分区消费进度 。  </p>
<p>写入偏移消息会调用 RepllcaManager .appendMessages ()方法，将消息集追加到本地日志文件，<br>并且会把分区和对应的偏移量保存在协调节点的缓存中 。 目的是：再平衡后如果其他消费者需要读取<br>分区的偏移毡 ， 在连接上协调节点后，可以直接读取缓存 ， 而不需要从日志文件中读取。  </p>
<h4 id="六、再平衡和分区分配"><a href="#六、再平衡和分区分配" class="headerlink" title="六、再平衡和分区分配"></a>六、再平衡和分区分配</h4><p>使用高级APl ，每个消费者进程启动时都会创建一个消费者连接器，并在ZK中注册消费者成员变<br>化、分区变化的监昕器。三旦监昕器注册的事件被触发，就会调用ZKRebalanceListener的再平衡方<br>法，为消费组的所有消费者重新分配分区 。 为了保证整个消费组分区分配算法的一致性，当一个消费<br>者触发再平衡时，该消费组内的所有消费者会同时触发再平衡。 如图（左）所示，第一个消费者<br>加入消费组触发再平衡，这时消费组只有一个消费者，所有的分区都分配给第一个消费者 。 如图<br>（右）所示，第二个消费者力n人同一个消费组，会触发所有消费者的再平衡，即第一个消费者和第二<br>个消费者都会再平衡。  </p>
<p><img src="https://yusp-spin.github.io/photo/kafka-rebalance.png" alt="消费组的消费者再平衡"></p>
<p>由于每个消费者的再平衡都是独立的进程，消费者之间并不知道其他消费者的再平衡最后有没有<br>成功。 可能有些消费者的再平衡成功了，有些却失败了，就会导致本来分配给这个消费者的分区，因为<br>再平衡失败而无法被消费，但是其他消费者又都无法知 l斑。 解决这个问题的方法是：在服务端为每个消<br>费组都选举一个协调节点，让它负责某个消费组中所有消费者的协调了作。 另外，消费者提交分区的偏<br>移i卫；也是写到协调节点上的 。 实际上，消费者客户端发送给服务端的请求“只要和消费组相关，都会被<br>协调节点处理” 。 如图所示，消费者执行再平衡和提交偏移ill都直接和协调者交互，具体步骤如下。<br>(I ）每个消费者触发再平衡时都和协调者联系，由协调者执行全局的分区分配 。<br>(2）协调者分配完成后，将分区分配给每个消费者 。<br>(3）每个消费者收到任务列表后，启动拉取钱程，拉取对应分区的消息，并更新拉取状态 。<br>(4）消费者周期性提交分区的偏移量给协调者，协调者将分区偏移写到内部主题 。  </p>
<p><img src="https://yusp-spin.github.io/photo/kakfa-rebalance.png" alt="消费者消费分区和提交偏移量都经过协调者"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2022/04/10/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF(%E9%AB%98%E7%BA%A7API)/" data-id="cl73fb6vs000frou9hp65hu6g" data-title="Kafka消费者消费消息(高级API)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Nginx学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/25/Nginx%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-09-25T10:51:12.000Z" itemprop="datePublished">2021-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/25/Nginx%E5%AD%A6%E4%B9%A0/">Nginx面试常问问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="1-nginx的负载均衡算法有哪些？"><a href="#1-nginx的负载均衡算法有哪些？" class="headerlink" title="1. nginx的负载均衡算法有哪些？"></a>1. nginx的负载均衡算法有哪些？</h5><p>Nginx的upstream模块支持6种方式的负载均衡策略（算法）：轮询（默认方式）、weight（权重方式）、ip_hash（依据ip分配方式）、least_conn（最少连接方式）、fair（第三方提供的响应时间方式）、url_hash（第三方通过的依据URL分配方式）。</p>
<h5 id="2-ngxin的作用"><a href="#2-ngxin的作用" class="headerlink" title="2. ngxin的作用"></a>2. ngxin的作用</h5><p>web 服务.</p>
<p>负载均衡 （反向代理）</p>
<p>web cache（web 缓存）</p>
<p>动静分离</p>
<h5 id="3-nginx的优点："><a href="#3-nginx的优点：" class="headerlink" title="3. nginx的优点："></a>3. nginx的优点：</h5><p>模块化、事件驱动、异步、非阻塞、多进程单线程</p>
<p>高并发。静态小文件</p>
<p>占用资源少。2万并发、10个线程，内存消耗几百M。</p>
<p>功能种类比较多。web,cache,proxy。每一个功能都不是特别强。</p>
<p>支持epoll模型，使得nginx可以支持高并发。</p>
<p>nginx 配合动态服务和Apache有区别。（FASTCGI 接口）</p>
<p>利用nginx可以对IP限速，可以限制连接数。</p>
<p>配置简单，更灵活。</p>
<h5 id="4-nginx为什么抗高并发"><a href="#4-nginx为什么抗高并发" class="headerlink" title="4. nginx为什么抗高并发"></a>4. nginx为什么抗高并发</h5><p>Nginx的高并发得益于其采用了epoll模型</p>
<p>nginx采用epoll模型，异步非阻塞。对于Nginx来说，把一个完整的连接请求处理都划分成了事件，一个一个的事件。比如accept（）， recv（），磁盘I/O，send（）等，每部分都有相应的模块去处理，一个完整的请求可能是由几百个模块去处理。真正核心的就是事件收集和分发模块，这就是管理所有模块的核心。只有核心模块的调度才能让对应的模块占用CPU资源，从而处理请求。拿一个HTTP请求来说，首先在事件收集分发模块注册感兴趣的监听事件，注册好之后不阻塞直接返回，接下来就不需要再管了，等待有连接来了内核会通知你(epoll的轮询会告诉进程)，cpu就可以处理其他事情去了。一旦有请求来，那么对整个请求分配相应的上下文（其实已经预先分配好），这时候再注册新的感兴趣的事件(read函数)，同样客户端数据来了内核会自动通知进程可以去读数据了，读了数据之后就是解析，解析完后去磁盘找资源（I/O），一旦I/O完成会通知进程，进程开始给客户端发回数据send()，这时候也不是阻塞的，调用后就等内核发回通知发送的结果就行。整个下来把一个请求分成了很多个阶段，每个阶段都到很多模块去注册，然后处理，都是异步非阻塞。异步这里指的就是做一个事情，不需要等返回结果，做好了会自动通知你。</p>
<h5 id="5-为什么nginx的总体性能比Apache高？"><a href="#5-为什么nginx的总体性能比Apache高？" class="headerlink" title="5. 为什么nginx的总体性能比Apache高？"></a>5. 为什么nginx的总体性能比Apache高？</h5><p>nginx使用最新的epoll和kqueue网络IO模型，而Apache使用传统的select模式。</p>
<p>目前Linux下能够承受高并发访问的squid、Memcached 都采用的是epoll网络IO模型。</p>
<h5 id="6-nginx如何处理请求？"><a href="#6-nginx如何处理请求？" class="headerlink" title="6. nginx如何处理请求？"></a>6. nginx如何处理请求？</h5><p>nginx在启动时会以daemon形式在后台运行，采用多进程+异步非阻塞IO事件模型来处理各种连接请求。多进程模型包括一个master进程，多个worker进程，一般worker进程个数是根据服务器CPU核数来决定的。master进程负责管理Nginx本身和其他worker进程</p>
<p>在nginx多进程中，每个worker都是平等的，因此每个进程处理外部请求的机会权重都是一致的。</p>
<p>Master进程读取并验证配置文件nginx.conf；管理worker进程；而每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。<strong>worker进程中有一个ngx_worker_process_cycle()函数，执行无限循环</strong>，不断处理收到的来自客户端的请求，并进行处理，那就要讲讲多进程模型的处理流程了。</p>
<h5 id="7-nginx多进程模式的处理流程"><a href="#7-nginx多进程模式的处理流程" class="headerlink" title="7. nginx多进程模式的处理流程"></a>7. nginx多进程模式的处理流程</h5><p>首先，master进程一开始就会根据我们的配置，来建立需要listen的网络socket fd，然后fork出多个worker进程。</p>
<p>其次，根据进程的特性，新建立的worker进程，也会和master进程一样，具有相同的设置。因此，其也会去监听相同ip端口的套接字socket fd。</p>
<p>然后，这个时候有多个worker进程都在监听同样设置的socket fd，意味着当有一个请求进来的时候，所有的worker都会感知到。这样就会产生所谓的“惊群现象”。为了保证只会有一个进程成功注册到listenfd的读事件，nginx中实现了一个“accept_mutex”类似互斥锁，只有获取到这个锁的进程，才可以去注册读事件。其他进程全部accept 失败。</p>
<p>最后，监听成功的worker进程，读取请求，解析处理，响应数据返回给客户端，断开连接，结束。因此，一个request请求，只需要worker进程就可以完成。</p>
<p>多进程模型的好处是进程之间独立，有一个worker坏了也不会影响逼得worker瘫痪</p>
<p>nginx还会将进程和cpu某一个核绑定，避免因为进程切换带来的缓存失效</p>
<h5 id="8-为什么要采用异步非阻塞？"><a href="#8-为什么要采用异步非阻塞？" class="headerlink" title="8. 为什么要采用异步非阻塞？"></a>8. 为什么要采用异步非阻塞？</h5><p>多进程模型+异步非阻塞模型才是胜出的方案。单纯的多进程模型会导致连接并发数量的降低，而采用异步非阻塞IO模型很好的解决了这个问题；并且还因此避免的多线程的上下文切换导致的性能损失。</p>
<h5 id="9-如何避免所有的请求都被一个worker进程给竞争获取了"><a href="#9-如何避免所有的请求都被一个worker进程给竞争获取了" class="headerlink" title="9. 如何避免所有的请求都被一个worker进程给竞争获取了"></a>9. 如何避免所有的请求都被一个worker进程给竞争获取了</h5><p>Nginx采用了一个是否打开accept_mutex选项的值，ngx_accept_disabled标识控制一个worker进程是否需要去竞争获取accept_mutex选项，进而获取accept事件</p>
<p>ngx_accept_disabled值：nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled。<br>当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空闲连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。</p>
<h5 id="10-nginx挂了怎么办？"><a href="#10-nginx挂了怎么办？" class="headerlink" title="10. nginx挂了怎么办？"></a>10. nginx挂了怎么办？</h5><p>Keepalived+Nginx实现高可用，Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。</p>
<p>第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</p>
<p>第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</p>
<ol start="11">
<li><h5 id="Nginx如何做到热部署？"><a href="#Nginx如何做到热部署？" class="headerlink" title="Nginx如何做到热部署？"></a>Nginx如何做到热部署？</h5></li>
</ol>
<p>修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/09/25/Nginx%E5%AD%A6%E4%B9%A0/" data-id="cl73fb6w7000prou9cmmnabff" data-title="Nginx面试常问问题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-RocketMQ实现分布式事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/25/RocketMQ%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2021-09-25T08:40:23.000Z" itemprop="datePublished">2021-09-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/25/RocketMQ%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">RocketMQ版的分布式事务实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、-什么是RocketMQ"><a href="#一、-什么是RocketMQ" class="headerlink" title="一、 什么是RocketMQ"></a>一、 什么是RocketMQ</h5><p>RocketMQ 是阿里巴巴开源的分布式消息中间件。支持消息重试、延时消息、消息追踪、实时消息、分布式事务消息等。它里面有几个区别于标准消息中件间的概念，如Group、Topic、Queue等。系统组成则由Producer、Consumer、Broker、NameServer等。</p>
<h5 id="二、RocketMQ-特点"><a href="#二、RocketMQ-特点" class="headerlink" title="二、RocketMQ 特点"></a>二、RocketMQ 特点</h5><ul>
<li>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点</li>
<li>Producer、Consumer、队列都可以分布式</li>
<li>Producer 向一些队列轮流发送消息，队列集合称为 Topic，Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列，如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合</li>
<li>能够保证严格的消息顺序</li>
<li>支持拉（pull）和推（push）两种消息模式</li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力</li>
<li>支持多种消息协议，如 JMS、OpenMessaging 等</li>
<li>较少的依赖</li>
</ul>
<h5 id="三、分布式场景"><a href="#三、分布式场景" class="headerlink" title="三、分布式场景"></a>三、分布式场景</h5><p>假设 <strong>A</strong> 给 <strong>B</strong> 转 <strong>100块钱</strong>，同时它们不是同一个服务上。</p>
<h5 id="目标：就是-A-减100块钱，B-加100块钱。"><a href="#目标：就是-A-减100块钱，B-加100块钱。" class="headerlink" title="目标：就是 A 减100块钱，B 加100块钱。"></a><code>目标</code>：就是 <strong>A</strong> 减100块钱，<strong>B</strong> 加100块钱。</h5><p>实际情况可能有四种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）就是A账户减100 （成功），B账户加100 （成功）</span><br><span class="line"></span><br><span class="line">2）就是A账户减100（失败），B账户加100 （失败）</span><br><span class="line"></span><br><span class="line">3）就是A账户减100（成功），B账户加100 （失败）</span><br><span class="line"></span><br><span class="line">4）就是A账户减100 （失败），B账户加100 （成功）</span><br></pre></td></tr></table></figure>

<p>这里 <strong>第1和第2</strong> 种情况是能够保证事务的一致性的，但是 <strong>第3和第4</strong> 是无法保证事务的一致性的。</p>
<p>那我们来看下RocketMQ是如何来保证事务的一致性的</p>
<h5 id="四、RocketMQ分布式事务原理"><a href="#四、RocketMQ分布式事务原理" class="headerlink" title="四、RocketMQ分布式事务原理"></a>四、RocketMQ分布式事务原理</h5><div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/rocketMq.jpg" width="700" height="300">
    <br>rocketMq分布式
    </p>
</div>


<p>1、A服务先发送个Half Message给Brock端，消息中携带 B服务 即将要+100元的信息。 2、当A服务知道Half Message发送成功后，那么开始第3步执行本地事务。 3、执行本地事务(会有三种情况1、执行成功。2、执行失败。3、网络等原因导致没有响应) 4.1)、如果本地事务成功，那么Product像Brock服务器发送Commit,这样B服务就可以消费该message。 4.2)、如果本地事务失败，那么Product像Brock服务器发送Rollback,那么就会直接删除上面这条半消息。 4.3)、如果因为网络等原因迟迟没有返回失败还是成功，那么会执行RocketMQ的回调接口,来进行事务的回查。</p>
<p>从上面流程可以得知 <code>只有A服务本地事务执行成功 ，B服务才能消费该message</code>。</p>
<p>然后我们再来思考几个问题？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么要先发送Half Message(半消息)</span><br></pre></td></tr></table></figure>

<p>我觉得主要有两点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）可以先确认 Brock服务器是否正常 ，如果半消息都发送失败了 那说明Brock挂了。</span><br><span class="line"></span><br><span class="line">2）可以通过半消息来回查事务，如果半消息发送成功后一直没有被二次确认，那么就会回查事务状态。</span><br><span class="line">什么情况会回查</span><br></pre></td></tr></table></figure>

<p>也会有两种情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）执行本地事务的时候，由于突然网络等原因一直没有返回执行事务的结果(commit或者rollback)导致最终返回UNKNOW，那么就会回查。</span><br><span class="line"></span><br><span class="line">2) 本地事务执行成功后，返回Commit进行消息二次确认的时候的服务挂了，在重启服务那么这个时候在brock端</span><br><span class="line">   它还是个Half Message(半消息)，这也会回查。</span><br></pre></td></tr></table></figure>

<p><strong>特别注意</strong>: 如果回查，那么<strong>一定要先查看当前事务的执行情况，再看是否需要重新执行本地事务。</strong></p>
<p>想象下如果出现第二种情况而引起的回查，如果不先查看当前事务的执行情况，而是直接执行事务，那么就相当于成功执行了两个本地事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么说MQ是最终一致性事务</span><br></pre></td></tr></table></figure>

<p>通过上面这幅图，我们可以看出，在上面举例事务不一致的两种情况中，永远不会发生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A账户减100 （失败），B账户加100 （成功）</span><br></pre></td></tr></table></figure>

<p><strong>因为</strong>：如果A服务本地事务都失败了，那B服务永远不会执行任何操作，因为消息压根就不会传到B服务。</p>
<p>那么 <strong>A账户减100 （成功），B账户加100 （失败）</strong> 会不会可能存在的。</p>
<p><strong>答案是会的</strong></p>
<p>因为A服务只负责当我消息执行成功了，保证消息能够送达到B,至于B服务接到消息后最终执行结果A并不管。</p>
<p><strong>那B服务失败怎么办？</strong></p>
<p>如果B最终执行失败，几乎可以断定就是代码有问题所以才引起的异常，因为消费端RocketMQ有重试机制，如果不是代码问题一般重试几次就能成功。</p>
<p>如果是代码的原因引起多次重试失败后，也没有关系，将该异常记录下来，由<code>人工处理</code>，人工兜底处理后，就可以让事务达到最终的一致性。</p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/weifeng1463/p/12889300.html">https://www.cnblogs.com/weifeng1463/p/12889300.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3afd610a8f7d">https://www.jianshu.com/p/3afd610a8f7d</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/09/25/RocketMQ%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" data-id="cl73fb6w7000srou968eaa6ur" data-title="RocketMQ版的分布式事务实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Netty中的零拷贝(Zero-Copy)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/05/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D(Zero-Copy)/" class="article-date">
  <time class="dt-published" datetime="2021-09-05T09:26:01.000Z" itemprop="datePublished">2021-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/05/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D(Zero-Copy)/">理解Netty中的零拷贝(Zero-Copy)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、理解零拷贝"><a href="#一、理解零拷贝" class="headerlink" title="一、理解零拷贝"></a>一、理解零拷贝</h5><p>​    <em>“Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another.</em></p>
<p>​    “零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。</p>
<div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/Zero-Copy.png" width="700" height="400">
    <br>零拷贝
    </p>
</div>



<p>Zero Copy的模式中，避免了数据在用户空间和内存空间之间的拷贝，从而提高了系统的整体性能。Linux中的<code>sendfile()</code>以及Java NIO中的<code>FileChannel.transferTo()</code>方法都实现了零拷贝的功能，而在Netty中也通过在<code>FileRegion</code>中包装了NIO的<code>FileChannel.transferTo()</code>方法实现了零拷贝。</p>
<h5 id="二、Netty中的零拷贝"><a href="#二、Netty中的零拷贝" class="headerlink" title="二、Netty中的零拷贝"></a>二、Netty中的零拷贝</h5><p>在Netty中还有另一种形式的零拷贝，即Netty允许我们将多段数据合并为一整段虚拟数据供用户使用，而过程中不需要对数据进行拷贝操作，这也是我们今天要讲的重点。我们都知道在stream-based transport（如TCP/IP）的传输过程中，数据包有可能会被重新封装在不同的数据包中，即 粘包</p>
<p>粘包怎么出现的呢?</p>
<p>我们知道TCP/IP协议是目前的主流网络协议。它是一个多层协议，最下层是物理层，最上层是应用层(HTTP协议等)，而做Java应用开发，一般只接触TCP以上，即传输层和应用层的内容。这也是Netty的主要应用场景。</p>
<p>TCP报文有个比较大的特点，就是它传输的时候，会先把应用层的数据项拆开成字节，然后按照自己的传输需要，选择合适数量的字节进行传输。什么叫”自己的传输需要”？首先TCP包有最大长度限制，那么太大的数据项肯定是要拆开的。其次因为TCP以及下层协议会附加一些协议头信息，如果数据项太小，那么可能报文大部分都是没有价值的头信息，这样传输是很不划算的。因此有了收集一定数量的小数据，并打包传输的Nagle算法(这个东东在HTTP协议里会很讨厌，Netty里可以用setOption(“tcpNoDelay”, true)关掉它)。</p>
<p>这么说可能不太好理解，我们举个例子吧：</p>
<p>发送时，我们这样分3次写入(‘|’表示两个buffer的分隔):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-----+-----+-----+</span><br><span class="line">| ABC | DEF | GHI |</span><br><span class="line">+-----+-----+-----+</span><br></pre></td></tr></table></figure>

<p>接收时，可能变成了这样:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+---+---+</span><br><span class="line">| AB | CDEFG | H | I |</span><br><span class="line">+----+-------+---+---+</span><br></pre></td></tr></table></figure>

<p>因此在实际应用中，很有可能一条完整的消息被分割为多个数据包进行网络传输，而单个的数据包对你而言是没有意义的，只有当这些数据包组成一条完整的消息时你才能做出正确的处理，而Netty可以通过零拷贝的方式将这些数据包组合成一条完整的消息供你来使用。而此时，零拷贝的作用范围仅在用户空间中。</p>
<h5 id="三、-Netty中的ChannelBuffer"><a href="#三、-Netty中的ChannelBuffer" class="headerlink" title="三、 Netty中的ChannelBuffer"></a>三、 Netty中的ChannelBuffer</h5><p>与Zero Copy直接相关的<code>CompositeChannelBuffer</code>类。 ###CompositeChannelBuffer类 <code>CompositeChannelBuffer</code>类的作用是将多个<code>ChannelBuffer</code>组成一个虚拟的<code>ChannelBuffer</code>来进行操作。为什么说是虚拟的呢，因为<code>CompositeChannelBuffer</code>并没有将多个<code>ChannelBuffer</code>真正的组合起来，而只是保存了他们的引用，这样就避免了数据的拷贝，实现了Zero Copy。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeChannelBuffer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//components保存所有内部ChannelBuffer</span></span><br><span class="line">    <span class="keyword">private</span> ChannelBuffer[] components;</span><br><span class="line">    <span class="comment">//indices记录在整个CompositeChannelBuffer中，每个components的起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indices;</span><br><span class="line">    <span class="comment">//缓存上一次读写的componentId</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastAccessedComponentId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过indices中记录的位置索引到对应第几个子Buffer</span></span><br><span class="line">        <span class="keyword">int</span> componentId = componentId(index);</span><br><span class="line">        <span class="keyword">return</span> components[componentId].getByte(index - indices[componentId]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setByte</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> componentId = componentId(index);</span><br><span class="line">        components[componentId].setByte(index - indices[componentId], value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>



<p>其中<code>readerIndex</code>既读指针和<code>writerIndex</code>既写指针是从<code>AbstractChannelBuffer</code>继承而来的；然后<code>components</code>是一个<code>ChannelBuffer</code>的数组，他保存了组成这个虚拟Buffer的所有子Buffer，<code>indices</code>是一个<code>int</code>类型的数组，它保存的是各个Buffer的索引值；最后的<code>lastAccessedComponentId</code>是一个<code>int</code>值，它记录了最后一次访问时的子Buffer ID。从这个数据结构，我们不难发现所谓的<code>CompositeChannelBuffer</code>实际上就是将一系列的Buffer通过数组保存起来，然后实现了<code>ChannelBuffer</code> 的接口，使得在上层看来，操作这些Buffer就像是操作一个单独的Buffer一样。</p>
<p>完全理解Netty零拷贝</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/plucury/blog/192577">https://my.oschina.net/plucury/blog/192577</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/code4craft/netty-learning/blob/master/posts/ch2-buffer.md">https://github.com/code4craft/netty-learning/blob/master/posts/ch2-buffer.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/09/05/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D(Zero-Copy)/" data-id="cl73fb6w7000lrou956dicw6v" data-title="理解Netty中的零拷贝(Zero-Copy)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AQS入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/29/AQS%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2021-03-29T06:59:23.000Z" itemprop="datePublished">2021-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8C%E6%AD%A5/">同步</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/29/AQS%E5%85%A5%E9%97%A8/">AQS介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、AQS的简单介绍"><a href="#一、AQS的简单介绍" class="headerlink" title="一、AQS的简单介绍"></a>一、AQS的简单介绍</h5><p>​     AQS的全称是AbstractQueuedSynchronizer ，这个类在 java.util.concurrent.locks 包下面 AQS是基于FIFO的队列实现的，并且内部维护了一个状态变量state，通过原子更新这个状态变量state即可以实现加锁解锁操作。 ReentrantLock，Semaphore，其他的如  CyclicBarrier  ，CountDownLatch，FutureTask SynchronousQueue等等皆是基于 AQS 的。 </p>
<p>​    当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。    </p>
<h5 id="二、源码介绍"><a href="#二、源码介绍" class="headerlink" title="二、源码介绍"></a>二、源码介绍</h5><ol>
<li>先看内部类，节点中保存着当前线程、前一个节点、后一个节点以及线程的状态等信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 互斥模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标识线程已取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标识后继节点需要唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 标识线程等待在一个条件上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 标识后面的共享锁需要无条件的传播（共享锁需要连续唤醒读的线程）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前节点保存的线程对应的等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后一个节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点保存的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个等待在条件上的节点（Condition锁时使用）</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造方法</span></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造方法</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="comment">// 把共享模式还是互斥模式存储到nextWaiter这个字段里面了</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造方法</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="comment">// 等待的状态，在Condition中使用</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>关键的state</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">// 控制加锁解锁的状态变量* private volatile int state; </span></span><br></pre></td></tr></table></figure>

<p>​     用volatile关键字来修饰，因为是在多线程环境下操作，要保证它们的值修改之后对其它线程立即可见 </p>
<p>state非常重要，所有的同步器都是通过stae来控制锁的状态。state的修改必须用cas</p>
<p>​    例如：CountDownLatch，首先通过构造函数设置state = n，需要countDown()执行n次，await()才会返回。这里用到的就是state，每当执行一次countDown()，state就-1，知道所有的子线程执行完毕，state为0，await()方法就可以返回</p>
<ol start="3">
<li>实现一个AQS所需要实现的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥模式下尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 互斥模式下尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享模式下尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 共享模式下尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前线程独占着锁，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里用到了一种设计模式，即模板方法模式，自定义同步器时只需要重写上面几个方法即可，AQS中其他类都是final类型的，只有这几个方法能被其它类使用。那么重写了几个方法为什么可以实现同步器呢？这是因为AQS父类已经帮我买写好了一系列操作，包括入队，出队等。具体操作等后面介绍具体同步器的时候就可以知道。后面会介绍ReentrantLock，CountDownLatch等。</p>
<h5 id="三、核心思想"><a href="#三、核心思想" class="headerlink" title="三、核心思想"></a>三、核心思想</h5><p>​    AQS核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效 的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需 要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现 的，即将暂时获取不到锁的线程加入到队列中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/03/29/AQS%E5%85%A5%E9%97%A8/" data-id="cl73fb6ux0001rou949yqgz3p" data-title="AQS介绍" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Kafka介绍（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/10/Kafka%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-01-10T06:59:23.000Z" itemprop="datePublished">2021-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/10/Kafka%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89/">Kafka介绍（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、Kafka架构介绍"><a href="#一、Kafka架构介绍" class="headerlink" title="一、Kafka架构介绍"></a>一、Kafka架构介绍</h5><p>​     一个典型的Kafka集群中包含若干Producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。 </p>
<div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/kafka.png" width="700" height="400">
    <br>kafka架构
    </p>
</div>

<h5 id="二、Topics和Partition的关系"><a href="#二、Topics和Partition的关系" class="headerlink" title="二、Topics和Partition的关系"></a>二、Topics和Partition的关系</h5><p>​     主题（topic）：一个 topic 里保存的是同一类消息，相当于对消息的分类，每个 producer 将消息发送到 kafka 中，都需要指明要存的 topic 是哪个，也就是指明这个消息属于哪一类。</p>
<p> 分区（partition）：每个 topic 都可以分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被直接追加到 log 文件的尾部。为什么要进行分区呢？最根本的原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。</p>
<p>​    Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。因为每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高 </p>
<h5 id="三、Consumer-Group"><a href="#三、Consumer-Group" class="headerlink" title="三、Consumer Group"></a>三、Consumer Group</h5><p>​    每一个consumer实例都属于一个consumer group，每一条消息只会被同一个consumer group里的一个consumer实例消费。（不同consumer group可以同时消费同一条消息）</p>
<p>　　很多传统的message queue都会在消息被消费完后将消息删除，一方面避免重复消费，另一方面可以保证queue的长度比较少，提高效率。而如上文所将，Kafka并不删除 已消费的消息，为了实现传统message queue消息只被消费一次的语义，Kafka保证保证同一个consumer group里只有一个consumer会消费一条消息。与传统message queue不同的是，Kafka还允许不同consumer group同时消费同一条消息，这一特性可以为消息的多元化处理提供了支持。实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。
　　 </p>
<h5 id="四、push-vs-pull"><a href="#四、push-vs-pull" class="headerlink" title="四、push vs pull"></a>四、push vs pull</h5><p>　　kafka采用的是传统的数据由producer推送给broker，然后由consumer从broker拉去的机制</p>
<h5 id="五、基本操作"><a href="#五、基本操作" class="headerlink" title="五、基本操作"></a>五、基本操作</h5><ol>
<li><p>启动ZooKeeper</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Kafka</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建主题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 </span><br><span class="line">--partitions 1 --topic Hello-World</span><br></pre></td></tr></table></figure>

<p> 刚刚创建了一个名为 `Hello-World的主题，其中包含一个分区和一个副本因子 </p>
</li>
<li><p>获取主题列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者发送消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-World</span><br></pre></td></tr></table></figure>

<p>然后就可以在终端键入消息</p>
</li>
<li><p>消费者消费消息.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Hello-World</span><br><span class="line">--from-beginning</span><br></pre></td></tr></table></figure>

</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/01/10/Kafka%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="cl73fb6vs000arou9cddr5dks" data-title="Kafka介绍（二）" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Kafka入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/08/Kafka%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2021-01-08T15:19:47.000Z" itemprop="datePublished">2021-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/08/Kafka%E5%85%A5%E9%97%A8/">kafka入门介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、消息系统介绍"><a href="#一、消息系统介绍" class="headerlink" title="一、消息系统介绍"></a>一、消息系统介绍</h5><p>​    消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用 - 一种是点对点，另一种是发布 - 订阅(pub-sub)消息系统。 大多数消息模式遵循 <strong>pub-sub</strong> </p>
<p><strong>点对点模式</strong></p>
<p>​    生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，所以Queue实现了一个可靠的负载均衡。</p>
<div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/point.png" width="700" height="400">
    <br>点对点
    </p>
</div>




<p><strong>发布订阅模式</strong></p>
<p>​    在发布 - 订阅系统中，消息被保留在主题中。 与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。 在发布 - 订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 </p>
<div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/topic.png" width="700" height="400">
    <br>发布订阅
    </p>
</div>


<h5 id="二、Kafka"><a href="#二、Kafka" class="headerlink" title="二、Kafka"></a>二、Kafka</h5><h6 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h6><p>Kafka专为分布式高吞吐量系统而设计。 Kafka往往工作得很好，作为一个更传统的消息代理的替代品。 与其他消息传递系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。</p>
<h6 id="2-2-Kafka的优势"><a href="#2-2-Kafka的优势" class="headerlink" title="2.2  Kafka的优势"></a>2.2  Kafka的优势</h6><p>以下是Kafka的几个好处 -</p>
<ul>
<li><strong>可靠性</strong> - Kafka是分布式，分区，复制和容错的。</li>
<li><strong>可扩展性</strong> - Kafka消息传递系统轻松缩放，无需停机。</li>
<li><strong>耐用性</strong> - Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。</li>
<li><strong>性能</strong> - Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。</li>
</ul>
<p>Kafka非常快，并保证零停机和零数据丢失。</p>
<p>Kafka可以在许多用例中使用。 其中一些列出如下 -</p>
<ul>
<li><strong>指标</strong> - Kafka通常用于操作监控数据。 这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。</li>
<li><strong>日志聚合解决方案</strong> - Kafka可用于跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。</li>
<li><strong>流处理</strong> - 流行的框架(如Storm和Spark Streaming)从主题中读取数据，对其进行处理，并将处理后的数据写入新主题，供用户和应用程序使用。 Kafka的强耐久性在流处理的上下文中也非常有用。</li>
</ul>
<h5 id="三、几大MQ比较"><a href="#三、几大MQ比较" class="headerlink" title="三、几大MQ比较"></a>三、几大MQ比较</h5><div>
    <p style="text-align:center">
    <img src="https://yusp-spin.github.io/photo/MQ.jpg" width="700" height="1400">
    <br>几大MQ对比
    </p>
</div>

<h5 id="四、Kafka基础"><a href="#四、Kafka基础" class="headerlink" title="四、Kafka基础"></a>四、Kafka基础</h5><h6 id="4-1-几大术语"><a href="#4-1-几大术语" class="headerlink" title="4.1 几大术语"></a>4.1 几大术语</h6><ul>
<li><p><strong>producer和consumer</strong>：消息的发送者叫 Producer，消息的使用者和接受者是 Consumer，生产者将数据保存到 Kafka 集群中，消费者从中获取消息进行业务的处理。</p>
</li>
<li><p><strong>broker</strong>：Kafka 集群中有很多台 Server，其中每一台 Server 都可以存储消息，将每一台 Server 称为一个 kafka 实例，也叫做 broker。</p>
</li>
<li><p><strong>topic</strong>：一个 topic 里保存的是同一类消息，相当于对消息的分类，每个 producer 将消息发送到 kafka 中，都需要指明要存的 topic 是哪个，也就是指明这个消息属于哪一类。</p>
</li>
<li><p><strong>partition</strong>：每个 topic 都可以分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被直接追加到 log 文件的尾部。为什么要进行分区呢？最根本的原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。</p>
</li>
<li><p><strong>Offset</strong>：一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为 offset（偏移量），offset 为一个 long 型数字，它可以唯一标记一条消息。由于kafka 并没有提供其他额外的索引机制来存储 offset，文件只能顺序的读写，所以在kafka中几乎不允许对消息进行“随机读写”。</p>
</li>
</ul>
<h5 id="五、Kafka的安装"><a href="#五、Kafka的安装" class="headerlink" title="五、Kafka的安装"></a>五、Kafka的安装</h5><p>​    首先要安装JDK（这个就不说了~）    </p>
<p>​    Apache Kafka 的一个关键依赖是 Apache Zookeeper，它是一个分布式配置和同步服务。Zookeeper 是 Kafka 代理和消费者之间的协调接口。Kafka 服务器通过 Zookeeper 集群共享信息。Kafka 在 Zookeeper 中存储基本元数据，例如关于主题，代理，消费者偏移(队列读取器)等的信息。</p>
<p>​    因此首先需要安装Zookeeper</p>
<h6 id="5-1-Zookeeper安装"><a href="#5-1-Zookeeper安装" class="headerlink" title="5.1 Zookeeper安装"></a>5.1 Zookeeper安装</h6><p>安装链接为：<a target="_blank" rel="noopener" href="http://zookeeper.apache.org/releases.html">http://zookeeper.apache.org/releases.html</a></p>
<p>下载的是tar.gz</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar -zxf zookeeper-3.4.6.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> zookeeper-3.4.6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir data</span></span><br></pre></td></tr></table></figure>

<p>创建配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim conf/zoo.cfg</span></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/path/to/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line">initLimit=5</span><br><span class="line">syncLimit=2</span><br></pre></td></tr></table></figure>

<p>启动Zookeeper服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/zkServer.sh start</span></span><br></pre></td></tr></table></figure>



<h6 id="5-2-Kafka安装"><a href="#5-2-Kafka安装" class="headerlink" title="5.2 Kafka安装"></a>5.2 Kafka安装</h6><p>下载链接：<a target="_blank" rel="noopener" href="https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz">https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz</a></p>
<p>解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -zxf kafka_2.11.0.9.0.0 tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> kafka_2.11.0.9.0.0</span></span><br></pre></td></tr></table></figure>

<p>启动Kafka</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure>







<p><strong><em>下一节我们将讨论Kafka的架构和基本操作</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2021/01/08/Kafka%E5%85%A5%E9%97%A8/" data-id="cl73fb6vs000crou92vld6e1g" data-title="kafka入门介绍" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-关于redisCluster" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/%E5%85%B3%E4%BA%8EredisCluster/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T12:55:34.000Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/31/%E5%85%B3%E4%BA%8EredisCluster/">Redis cluster集群模式介绍</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="一、Redis主从概念"><a href="#一、Redis主从概念" class="headerlink" title="一、Redis主从概念"></a>一、Redis主从概念</h5><p>​     为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。 </p>
<p>​     在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。 </p>
<h5 id="二、为什么要有集群？"><a href="#二、为什么要有集群？" class="headerlink" title="二、为什么要有集群？"></a>二、为什么要有集群？</h5><p>​    redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。</p>
<h5 id="三、数据分布算法"><a href="#三、数据分布算法" class="headerlink" title="三、数据分布算法"></a>三、数据分布算法</h5><h6 id="3-1-hash算法"><a href="#3-1-hash算法" class="headerlink" title="3.1  hash算法"></a>3.1  hash算法</h6><p>​     哈希算法的思想非常简单，也许你知道 HashMap 的哈希函数，哈希算法跟 HashMap 一样，也是通过一个哈希函数得到某一个数字，然后根据数字找到相应的服务器。 </p>
<p>​    比如有N个redis实例，那么如何将key映射到redis上呢？</p>
<p>​    通常是采用hash算法计算key的hash值，然后通过取模，均匀的映射到N个redis服务器上，如果增加一个服务器，那么映射公式就变成了hash(key)%(N+1)，如果有一个服务器宕机了，映射公式变成了hash(key)%(N-1)</p>
<p>​    这种情况下，几乎所有的缓存都失效了，会导致数据库访问的压力陡增，甚至导致数据库宕机</p>
<h6 id="3-2-一致性hash算法"><a href="#3-2-一致性hash算法" class="headerlink" title="3.2 一致性hash算法"></a>3.2 一致性hash算法</h6><p>​     一致性哈希算法可以说是哈希算法的升级版，解决了哈希算法扩展性差的问题，一致性哈希算法跟哈希算法不一样，一致性哈希算法会将服务器和数据都通过哈希函数映射到一个首尾相连的哈希环上 </p>
<p>具体步骤如下：</p>
<ol>
<li>首先求出服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。</li>
<li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li>
<li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。</li>
</ol>
<p><img src="/photo/hash1.png" alt="hash1"></p>
<p><img src="/photo/hash2.png" alt="hash2"></p>
<p>可能存在的问题：</p>
<p>​     一个master宕机不会导致大部分缓存失效，可能存在缓存热点问题 ，比如某个区间的值特别多没那么会导致大量的数据都涌入一个服务器内，造成缓存热点问题，出现性能瓶颈</p>
<p><img src="/photo/hash3.png" alt="hash3"></p>
<h6 id="3-3-用虚拟节点改进的一致性hash算法"><a href="#3-3-用虚拟节点改进的一致性hash算法" class="headerlink" title="3.3 用虚拟节点改进的一致性hash算法"></a>3.3 用虚拟节点改进的一致性hash算法</h6><p>​    缓存热点问题是在服务器节点数非常少的时候容易出现，因此，我们通过添加虚拟节点的方式，来使的服务器节点数变多，从而大量数据均匀分布，而不是涌入到一个服务器内</p>
<p><img src="/photo/hash4.png" alt="hash4"></p>
<h6 id="3-4-rediscluster的hash-slot算法"><a href="#3-4-rediscluster的hash-slot算法" class="headerlink" title="3.4  rediscluster的hash slot算法"></a>3.4  rediscluster的hash slot算法</h6><p>​     <a href>redis</a> cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot 。hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去</p>
<p>​    <a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>的api，可以对指定的数据，让他们走同一个hash slot，通过hash tag来实现</p>
<p>​    <a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>向节点发送键命令，节点要计算这个键属于哪个槽。如果是自己负责这个槽，那么直接执行命令，如果不是，向<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>返回一个MOVED错误，指引<a target="_blank" rel="noopener" href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a>转向正确的节点。</p>
<h5 id="四、节点间的通信机制"><a href="#四、节点间的通信机制" class="headerlink" title="四、节点间的通信机制"></a>四、节点间的通信机制</h5><p><strong>1.基础通信</strong></p>
<p>（1）<a href>redis</a> cluster节点间采取gossip协议进行通信 </p>
<p>  跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的 </p>
<p>  集中式：好处在于，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到; 不好在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力 </p>
<p>  gossip：好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力; 缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后 </p>
<p> （2）10000端口 </p>
<p>  每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口 </p>
<p>  每隔节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping之后返回pong </p>
<p> （3）交换的信息 </p>
<p>  故障信息，节点的增加和移除，hash slot信息，等等</p>
<p><strong>2. gossip协议</strong> </p>
<ol>
<li><p>meet: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信 </p>
</li>
<li><p> ping: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据 每个节点每秒都会频繁发送ping给其他的集群，ping，频繁的互相之间交换数据，互相进行元数据的更新 </p>
</li>
<li><p> pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新 </p>
</li>
<li><p>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了</p>
</li>
</ol>
<h5 id="五、redis-cluster-的高可用与主备切换原理"><a href="#五、redis-cluster-的高可用与主备切换原理" class="headerlink" title="五、redis cluster 的高可用与主备切换原理"></a>五、redis cluster 的高可用与主备切换原理</h5><p>redis cluster 的高可用的原理，<strong>几乎跟哨兵是类似</strong>的。</p>
<h6 id="5-1-判断节点宕机"><a href="#5-1-判断节点宕机" class="headerlink" title="5.1 判断节点宕机"></a>5.1 判断节点宕机</h6><p>如果<strong>一个节点</strong>认为另外一个节点宕机，那么就是 <code>pfail</code>，<strong>主观宕机</strong>。如果<strong>多个节点</strong>都认为另外一个节点宕机了，那么就是 <code>fail</code>，<strong>客观宕机</strong>，跟哨兵的原理几乎一样，<strong>sdown</strong>，<strong>odown</strong>。</p>
<p>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 <code>pong</code>，那么就被认为 <code>pfail</code>。</p>
<p>如果一个节点认为某个节点 <code>pfail</code> 了，那么会在 <code>gossip ping</code> 消息中，<code>ping</code> 给其他节点，如果<strong>超过半数</strong>的节点都认为 <code>pfail</code> 了，那么就会变成 <code>fail</code>。</p>
<h6 id="5-2-从节点过滤"><a href="#5-2-从节点过滤" class="headerlink" title="5.2 从节点过滤"></a>5.2 从节点过滤</h6><p>对宕机的 master node，<strong>从其所有的 slave node 中</strong>，<strong>选择一个切换成 master node</strong>。</p>
<p>检查每个 slave node 与 master node 断开连接的时间，如果超过了 <code>cluster-node-timeout * cluster-slave-validity-factor</code>，那么就<strong>没有资格</strong>切换成 <code>master</code>。</p>
<h6 id="5-3-从节点选举"><a href="#5-3-从节点选举" class="headerlink" title="5.3 从节点选举"></a>5.3 从节点选举</h6><p>每个<strong>从节点</strong>，都根据自己<strong>对 master 复制数据的 offset</strong>，来设置一个<strong>选举时间</strong>，offset 越大（<strong>复制数据越多</strong>）的从节点，<strong>选举时间越靠前</strong>，优先进行选举。</p>
<p>所有的 <strong>master node 开始 slave 选举投票</strong>，给要进行选举的 slave 进行投票，如果<strong>大部分</strong> master node<code>（N/2 + 1）</code>都投票给了某个<strong>从节点</strong>，那么<strong>选举通过</strong>，那个从节点可以切换成 master。</p>
<p>从节点<strong>执行主备切换</strong>，从节点切换为主节点。</p>
<h6 id="5-4-与哨兵比较"><a href="#5-4-与哨兵比较" class="headerlink" title="5.4 与哨兵比较"></a>5.4 与哨兵比较</h6><p>整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接<strong>集成了 replication 和 sentinel</strong> 的功能。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><em>部分文字参考链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/364714?type=post&amp;order=time&amp;pos=&amp;page=0">https://www.nowcoder.com/discuss/364714?type=post&amp;order=time&amp;pos=&amp;page=0</a></em></p>
<p><em>图片为作者所绘制，不存在参考</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2020/12/31/%E5%85%B3%E4%BA%8EredisCluster/" data-id="cl73fb6wn001irou9ejyte1yc" data-title="Redis cluster集群模式介绍" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TopK问题用快排和堆排的复杂度分别是多少？" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/21/TopK%E9%97%AE%E9%A2%98%E7%94%A8%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/" class="article-date">
  <time class="dt-published" datetime="2020-12-21T02:22:56.000Z" itemprop="datePublished">2020-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/21/TopK%E9%97%AE%E9%A2%98%E7%94%A8%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/">TopK问题用快排和堆排的复杂度分别是多少？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><h5 id="关于TopK问题"><a href="#关于TopK问题" class="headerlink" title="关于TopK问题"></a>关于TopK问题</h5><p>TopK问题就是在一堆数据里面找到前 K 大(当然也可以是前 K 小)的数</p>
</li>
<li><h5 id="常规方法，完全排序"><a href="#常规方法，完全排序" class="headerlink" title="常规方法，完全排序"></a>常规方法，完全排序</h5><p>先完全排序后取topK，这种方法需要将数据完全排序，不适用于大数据量</p>
</li>
<li><h5 id="利用快排"><a href="#利用快排" class="headerlink" title="利用快排"></a>利用快排</h5><h6 id="3-1-解决思路"><a href="#3-1-解决思路" class="headerlink" title="3.1 解决思路"></a>3.1 解决思路</h6><p>借鉴快排的思想，在patiton中数组会分为三个部分，我们只要与index相比较就可以得出TopK是在左边部分还是右边部分，因此不需要全部排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要求的第k个数</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">GetLeastNumbers</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.length &lt; k || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        quick_sort(input, <span class="number">0</span>, input.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = patiton(arr, l, r);</span><br><span class="line">        <span class="comment">//此处判断就是为了变成局部排序</span></span><br><span class="line">        <span class="keyword">if</span>(index == k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">                res.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index &gt;= k) &#123;</span><br><span class="line">            quick_sort(arr, l ,index - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            quick_sort(arr, index + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">patiton</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[l];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;arr[r]&gt;=tmp)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[l]=arr[r];</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r&amp;&amp;arr[l]&lt;=tmp)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[r]=arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l]=tmp;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-2-复杂度分析"><a href="#3-2-复杂度分析" class="headerlink" title="3.2 复杂度分析"></a>3.2 复杂度分析</h6><p>​    与快排完全排序不同，每次分割后的数组大小近似为原数组大小的一半，因此这种方法的时间复杂度实际上是O(N)+O(N/2)+O(N/4)+……＜O(2N)，因此时间复杂度为**O(N)**，但是这种方法需要提前将N个数读入，对于海量数据来说，对空间开销很大</p>
</li>
<li><h5 id="堆排序法"><a href="#堆排序法" class="headerlink" title="堆排序法"></a>堆排序法</h5><h6 id="4-1-解决思路"><a href="#4-1-解决思路" class="headerlink" title="4.1 解决思路"></a>4.1 解决思路</h6><p>​    先随机取出N个数中的K个数，将这N个数构造为小顶堆，那么堆顶的数肯定就是这K个数中最小的数了，然后再将剩下的N-K个数与堆顶进行比较，如果大于堆顶，那么说明该数有机会成为TopK，就更新堆顶为该数，此时由于小顶堆的性质可能被破坏，就还需要调整堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (input.length &lt; k || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> len = input.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; k || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size() &lt; k) &#123;</span><br><span class="line">                queue.add(input[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek() &gt; input[i]) &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.add(input[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-2-复杂度分析"><a href="#4-2-复杂度分析" class="headerlink" title="4.2 复杂度分析"></a>4.2 复杂度分析</h6><p>​    首先需要对K个元素进行建堆，时间复杂度为O(k)，然后要遍历数组,最坏的情况是，每个元素都与堆顶比较并排序，需要堆化n次 所以是O(nlog(k))，因此总复杂度是<strong>O(k+nlog(k))</strong>;</p>
<h5 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h5><p>​    快排和堆排解决topK问题的复杂度其实面试中有被问过，有不少面试者直接答的快排和堆排的复杂度，但其实是不一样的，在TopK问题中，快排和堆排的复杂度分别问<strong>O(n)和O(k+nlog(k))</strong></p>
<p>​    通过对比可以发现，堆排的优势是只需读入K个数据即可，可以实现来一个数据更新一次，能够很好的实现数据动态读入并找出TopK。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.yusp-spin.github.io/2020/12/21/TopK%E9%97%AE%E9%A2%98%E7%94%A8%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/" data-id="cl73fb6w7000xrou9ht152cy1" data-title="TopK问题用快排和堆排的复杂度分别是多少？" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TopK/" rel="tag">TopK</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>
</section>
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Goroutine/" rel="tag">Goroutine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Netty/" rel="tag">Netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TopK/" rel="tag">TopK</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87offer/" rel="tag">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/" rel="tag">线程封闭</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E5%8C%85/" rel="tag">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag">进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/" rel="tag">零拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E7%BB%8F/" rel="tag">面经</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/21/ZGC%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/">ZGC简介</a>
          </li>
        
          <li>
            <a href="/2022/04/10/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF(%E9%AB%98%E7%BA%A7API)/">Kafka消费者消费消息(高级API)</a>
          </li>
        
          <li>
            <a href="/2021/09/25/Nginx%E5%AD%A6%E4%B9%A0/">Nginx面试常问问题</a>
          </li>
        
          <li>
            <a href="/2021/09/25/RocketMQ%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">RocketMQ版的分布式事务实现</a>
          </li>
        
          <li>
            <a href="/2021/09/05/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D(Zero-Copy)/">理解Netty中的零拷贝(Zero-Copy)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Gin%E6%A1%86%E6%9E%B6/">Gin框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go%E5%9F%BA%E7%A1%80/">Go基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot-%E6%A1%86%E6%9E%B6/">SpringBoot 框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8C%E6%AD%A5/">同步</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">垃圾回收</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88go%EF%BC%89/">并发编程（go）</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88java%EF%BC%89/">并发编程（java）</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li></ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 By Autoload<br>
      Driven - <a href="https://hexo.io/" target="_blank">Hexo</a>|Theme - <a href="https://github.com/autoload/hexo-theme-auto" target="_blank">Auto</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/tags/%E6%97%A5%E5%B8%B8/" class="mobile-nav-link">杂谈</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>