{"meta":{"title":"如果方向错误，停止前进就是一种进步","subtitle":"","description":"","author":"spin","url":"https://www.yusp-spin.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-09-14T02:04:27.000Z","updated":"2020-09-14T02:23:16.153Z","comments":true,"path":"categories/index.html","permalink":"https://www.yusp-spin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-14T01:55:43.000Z","updated":"2020-09-14T01:57:00.938Z","comments":true,"path":"tags/index.html","permalink":"https://www.yusp-spin.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-09-11T15:56:12.301Z","updated":"2021-09-11T15:56:12.301Z","comments":true,"path":"about/index.html","permalink":"https://www.yusp-spin.github.io/about/index.html","excerpt":"","text":"昵称：​ Spin 教育经历：​ 东南大学本科 / 中国科学技术大学硕士 领域：​ 后端、Java、广告研发 就职：​ 北京快手科技有限公司 联系方式：​ &#x36;&#50;&#51;&#x38;&#49;&#55;&#x35;&#54;&#53;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;（需要内推快手可发简历至该邮箱） 技术栈(不代表熟练)：​ 语言：Java、Go（入门） ​ 数据库：MySQL， Redis，Mongdb、ClickHouse、Hbase ​ 中间件：ZooKeeper，Nginx，Shiro ​ Web框架：Spring，SpringBoot，Gin ​ 微服务：SpringCloud、Grpc、Dubbo 其它博客：​ GitHub: https://github.com/yusp-spin/Study/blob/main/Notes.md ​ CSDN: https://blog.csdn.net/qq_21903759 ​ 简书: https://www.jianshu.com/u/15f11da6e1a0 爱好：​ …… 关于： 非科班码农，全靠自学 博客纯粹为了做笔记和自娱自乐 选择大于努力"}],"posts":[{"title":"理解Netty中的零拷贝(Zero-Copy)","slug":"Netty中的零拷贝(Zero-Copy)","date":"2021-09-05T09:26:01.000Z","updated":"2021-09-05T09:51:16.613Z","comments":true,"path":"2021/09/05/Netty中的零拷贝(Zero-Copy)/","link":"","permalink":"https://www.yusp-spin.github.io/2021/09/05/Netty%E4%B8%AD%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D(Zero-Copy)/","excerpt":"","text":"一、理解零拷贝​ “Zero-copy” describes computer operations in which the CPU does not perform the task of copying data from one memory area to another. ​ “零拷贝”是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。 零拷贝 Zero Copy的模式中，避免了数据在用户空间和内存空间之间的拷贝，从而提高了系统的整体性能。Linux中的sendfile()以及Java NIO中的FileChannel.transferTo()方法都实现了零拷贝的功能，而在Netty中也通过在FileRegion中包装了NIO的FileChannel.transferTo()方法实现了零拷贝。 二、Netty中的零拷贝在Netty中还有另一种形式的零拷贝，即Netty允许我们将多段数据合并为一整段虚拟数据供用户使用，而过程中不需要对数据进行拷贝操作，这也是我们今天要讲的重点。我们都知道在stream-based transport（如TCP/IP）的传输过程中，数据包有可能会被重新封装在不同的数据包中，即 粘包 粘包怎么出现的呢? 我们知道TCP/IP协议是目前的主流网络协议。它是一个多层协议，最下层是物理层，最上层是应用层(HTTP协议等)，而做Java应用开发，一般只接触TCP以上，即传输层和应用层的内容。这也是Netty的主要应用场景。 TCP报文有个比较大的特点，就是它传输的时候，会先把应用层的数据项拆开成字节，然后按照自己的传输需要，选择合适数量的字节进行传输。什么叫”自己的传输需要”？首先TCP包有最大长度限制，那么太大的数据项肯定是要拆开的。其次因为TCP以及下层协议会附加一些协议头信息，如果数据项太小，那么可能报文大部分都是没有价值的头信息，这样传输是很不划算的。因此有了收集一定数量的小数据，并打包传输的Nagle算法(这个东东在HTTP协议里会很讨厌，Netty里可以用setOption(“tcpNoDelay”, true)关掉它)。 这么说可能不太好理解，我们举个例子吧： 发送时，我们这样分3次写入(‘|’表示两个buffer的分隔): 123+-----+-----+-----+| ABC | DEF | GHI |+-----+-----+-----+ 接收时，可能变成了这样: 123+----+-------+---+---+| AB | CDEFG | H | I |+----+-------+---+---+ 因此在实际应用中，很有可能一条完整的消息被分割为多个数据包进行网络传输，而单个的数据包对你而言是没有意义的，只有当这些数据包组成一条完整的消息时你才能做出正确的处理，而Netty可以通过零拷贝的方式将这些数据包组合成一条完整的消息供你来使用。而此时，零拷贝的作用范围仅在用户空间中。 三、 Netty中的ChannelBuffer与Zero Copy直接相关的CompositeChannelBuffer类。 ###CompositeChannelBuffer类 CompositeChannelBuffer类的作用是将多个ChannelBuffer组成一个虚拟的ChannelBuffer来进行操作。为什么说是虚拟的呢，因为CompositeChannelBuffer并没有将多个ChannelBuffer真正的组合起来，而只是保存了他们的引用，这样就避免了数据的拷贝，实现了Zero Copy。 123456789101112131415161718192021public class CompositeChannelBuffer&#123; //components保存所有内部ChannelBuffer private ChannelBuffer[] components; //indices记录在整个CompositeChannelBuffer中，每个components的起始位置 private int[] indices; //缓存上一次读写的componentId private int lastAccessedComponentId; public byte getByte(int index) &#123; //通过indices中记录的位置索引到对应第几个子Buffer int componentId = componentId(index); return components[componentId].getByte(index - indices[componentId]); &#125; public void setByte(int index, int value) &#123; int componentId = componentId(index); components[componentId].setByte(index - indices[componentId], value); &#125;&#125; 其中readerIndex既读指针和writerIndex既写指针是从AbstractChannelBuffer继承而来的；然后components是一个ChannelBuffer的数组，他保存了组成这个虚拟Buffer的所有子Buffer，indices是一个int类型的数组，它保存的是各个Buffer的索引值；最后的lastAccessedComponentId是一个int值，它记录了最后一次访问时的子Buffer ID。从这个数据结构，我们不难发现所谓的CompositeChannelBuffer实际上就是将一系列的Buffer通过数组保存起来，然后实现了ChannelBuffer 的接口，使得在上层看来，操作这些Buffer就像是操作一个单独的Buffer一样。 完全理解Netty零拷贝 参考： https://my.oschina.net/plucury/blog/192577 https://github.com/code4craft/netty-learning/blob/master/posts/ch2-buffer.md","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/tags/Netty/"}]},{"title":"AQS介绍","slug":"AQS入门","date":"2021-03-29T06:59:23.000Z","updated":"2021-04-04T06:27:42.635Z","comments":true,"path":"2021/03/29/AQS入门/","link":"","permalink":"https://www.yusp-spin.github.io/2021/03/29/AQS%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、AQS的简单介绍​ AQS的全称是AbstractQueuedSynchronizer ，这个类在 java.util.concurrent.locks 包下面 AQS是基于FIFO的队列实现的，并且内部维护了一个状态变量state，通过原子更新这个状态变量state即可以实现加锁解锁操作。 ReentrantLock，Semaphore，其他的如 CyclicBarrier ，CountDownLatch，FutureTask SynchronousQueue等等皆是基于 AQS 的。 ​ 当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。 二、源码介绍 先看内部类，节点中保存着当前线程、前一个节点、后一个节点以及线程的状态等信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static final class Node &#123; // 共享模式 static final Node SHARED = new Node(); // 互斥模式 static final Node EXCLUSIVE = null; // 标识线程已取消 static final int CANCELLED = 1; // 标识后继节点需要唤醒 static final int SIGNAL = -1; // 标识线程等待在一个条件上 static final int CONDITION = -2; // 标识后面的共享锁需要无条件的传播（共享锁需要连续唤醒读的线程） static final int PROPAGATE = -3; // 当前节点保存的线程对应的等待状态 volatile int waitStatus; // 前一个节点 volatile Node prev; // 后一个节点 volatile Node next; // 当前节点保存的线程 volatile Thread thread; // 下一个等待在条件上的节点（Condition锁时使用） Node nextWaiter; // 是否是共享模式 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 获取前一个节点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; // 节点的构造方法 Node() &#123; // Used to establish initial head or SHARED marker &#125; // 节点的构造方法 Node(Thread thread, Node mode) &#123; // Used by addWaiter // 把共享模式还是互斥模式存储到nextWaiter这个字段里面了 this.nextWaiter = mode; this.thread = thread; &#125; // 节点的构造方法 Node(Thread thread, int waitStatus) &#123; // Used by Condition // 等待的状态，在Condition中使用 this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 关键的state 1*// 控制加锁解锁的状态变量* private volatile int state; ​ 用volatile关键字来修饰，因为是在多线程环境下操作，要保证它们的值修改之后对其它线程立即可见 state非常重要，所有的同步器都是通过stae来控制锁的状态。state的修改必须用cas ​ 例如：CountDownLatch，首先通过构造函数设置state = n，需要countDown()执行n次，await()才会返回。这里用到的就是state，每当执行一次countDown()，state就-1，知道所有的子线程执行完毕，state为0，await()方法就可以返回 实现一个AQS所需要实现的方法 123456789101112131415161718192021// 互斥模式下尝试获取锁protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125;// 互斥模式下尝试释放锁protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;// 共享模式下尝试获取锁protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// 共享模式下尝试释放锁protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125;// 如果当前线程独占着锁，返回trueprotected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException();&#125; 这里用到了一种设计模式，即模板方法模式，自定义同步器时只需要重写上面几个方法即可，AQS中其他类都是final类型的，只有这几个方法能被其它类使用。那么重写了几个方法为什么可以实现同步器呢？这是因为AQS父类已经帮我买写好了一系列操作，包括入队，出队等。具体操作等后面介绍具体同步器的时候就可以知道。后面会介绍ReentrantLock，CountDownLatch等。 三、核心思想​ AQS核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效 的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需 要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现 的，即将暂时获取不到锁的线程加入到队列中","categories":[{"name":"同步","slug":"同步","permalink":"https://www.yusp-spin.github.io/categories/%E5%90%8C%E6%AD%A5/"}],"tags":[]},{"title":"Kafka介绍（二）","slug":"Kafka介绍（二）","date":"2021-01-10T06:59:23.000Z","updated":"2021-08-22T07:03:21.574Z","comments":true,"path":"2021/01/10/Kafka介绍（二）/","link":"","permalink":"https://www.yusp-spin.github.io/2021/01/10/Kafka%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"一、Kafka架构介绍​ 一个典型的Kafka集群中包含若干Producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个Zookeeper集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息。 kafka架构 二、Topics和Partition的关系​ 主题（topic）：一个 topic 里保存的是同一类消息，相当于对消息的分类，每个 producer 将消息发送到 kafka 中，都需要指明要存的 topic 是哪个，也就是指明这个消息属于哪一类。 分区（partition）：每个 topic 都可以分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被直接追加到 log 文件的尾部。为什么要进行分区呢？最根本的原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。 ​ Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。创建一个topic时，同时可以指定分区数目，分区数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到生产者发送的消息之后，会根据均衡策略将消息存储到不同的分区中。因为每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高 三、Consumer Group​ 每一个consumer实例都属于一个consumer group，每一条消息只会被同一个consumer group里的一个consumer实例消费。（不同consumer group可以同时消费同一条消息） 很多传统的message queue都会在消息被消费完后将消息删除，一方面避免重复消费，另一方面可以保证queue的长度比较少，提高效率。而如上文所将，Kafka并不删除 已消费的消息，为了实现传统message queue消息只被消费一次的语义，Kafka保证保证同一个consumer group里只有一个consumer会消费一条消息。与传统message queue不同的是，Kafka还允许不同consumer group同时消费同一条消息，这一特性可以为消息的多元化处理提供了支持。实际上，Kafka的设计理念之一就是同时提供离线处理和实时处理。 四、push vs pull kafka采用的是传统的数据由producer推送给broker，然后由consumer从broker拉去的机制 五、基本操作 启动ZooKeeper 1bin/zookeeper-server-start.sh config/zookeeper.properties 启动Kafka 1bin/kafka-server-start.sh config/server.properties 创建主题 12bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-World 刚刚创建了一个名为 `Hello-World的主题，其中包含一个分区和一个副本因子 获取主题列表 1bin/kafka-topics.sh --list --zookeeper localhost:2181 生产者发送消息 1bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-World 然后就可以在终端键入消息 消费者消费消息. 12bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Hello-World--from-beginning","categories":[{"name":"消息队列","slug":"消息队列","permalink":"https://www.yusp-spin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"kafka入门介绍","slug":"Kafka入门","date":"2021-01-08T15:19:47.000Z","updated":"2021-08-22T07:02:57.029Z","comments":true,"path":"2021/01/08/Kafka入门/","link":"","permalink":"https://www.yusp-spin.github.io/2021/01/08/Kafka%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、消息系统介绍​ 消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用 - 一种是点对点，另一种是发布 - 订阅(pub-sub)消息系统。 大多数消息模式遵循 pub-sub 点对点模式 ​ 生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，所以Queue实现了一个可靠的负载均衡。 点对点 发布订阅模式 ​ 在发布 - 订阅系统中，消息被保留在主题中。 与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。 在发布 - 订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 发布订阅 二、Kafka2.1 介绍Kafka专为分布式高吞吐量系统而设计。 Kafka往往工作得很好，作为一个更传统的消息代理的替代品。 与其他消息传递系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 2.2 Kafka的优势以下是Kafka的几个好处 - 可靠性 - Kafka是分布式，分区，复制和容错的。 可扩展性 - Kafka消息传递系统轻松缩放，无需停机。 耐用性 - Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。 性能 - Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。 Kafka非常快，并保证零停机和零数据丢失。 Kafka可以在许多用例中使用。 其中一些列出如下 - 指标 - Kafka通常用于操作监控数据。 这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。 日志聚合解决方案 - Kafka可用于跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。 流处理 - 流行的框架(如Storm和Spark Streaming)从主题中读取数据，对其进行处理，并将处理后的数据写入新主题，供用户和应用程序使用。 Kafka的强耐久性在流处理的上下文中也非常有用。 三、几大MQ比较 几大MQ对比 四、Kafka基础4.1 几大术语 producer和consumer：消息的发送者叫 Producer，消息的使用者和接受者是 Consumer，生产者将数据保存到 Kafka 集群中，消费者从中获取消息进行业务的处理。 broker：Kafka 集群中有很多台 Server，其中每一台 Server 都可以存储消息，将每一台 Server 称为一个 kafka 实例，也叫做 broker。 topic：一个 topic 里保存的是同一类消息，相当于对消息的分类，每个 producer 将消息发送到 kafka 中，都需要指明要存的 topic 是哪个，也就是指明这个消息属于哪一类。 partition：每个 topic 都可以分成多个 partition，每个 partition 在存储层面是 append log 文件。任何发布到此 partition 的消息都会被直接追加到 log 文件的尾部。为什么要进行分区呢？最根本的原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区的办法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。 Offset：一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为 offset（偏移量），offset 为一个 long 型数字，它可以唯一标记一条消息。由于kafka 并没有提供其他额外的索引机制来存储 offset，文件只能顺序的读写，所以在kafka中几乎不允许对消息进行“随机读写”。 五、Kafka的安装​ 首先要安装JDK（这个就不说了~） ​ Apache Kafka 的一个关键依赖是 Apache Zookeeper，它是一个分布式配置和同步服务。Zookeeper 是 Kafka 代理和消费者之间的协调接口。Kafka 服务器通过 Zookeeper 集群共享信息。Kafka 在 Zookeeper 中存储基本元数据，例如关于主题，代理，消费者偏移(队列读取器)等的信息。 ​ 因此首先需要安装Zookeeper 5.1 Zookeeper安装安装链接为：http://zookeeper.apache.org/releases.html 下载的是tar.gz 123$ tar -zxf zookeeper-3.4.6.tar.gz$ cd zookeeper-3.4.6$ mkdir data 创建配置文件 123456$ vim conf/zoo.cfgtickTime=2000dataDir=/path/to/zookeeper/dataclientPort=2181initLimit=5syncLimit=2 启动Zookeeper服务器 1$ bin/zkServer.sh start 5.2 Kafka安装下载链接：https://www.apache.org/dyn/closer.cgi?path=/kafka/0.9.0.0/kafka_2.11-0.9.0.0.tgz 解压 123$ cd opt/$ tar -zxf kafka_2.11.0.9.0.0 tar.gz$ cd kafka_2.11.0.9.0.0 启动Kafka 1$ bin/kafka-server-start.sh config/server.properties 下一节我们将讨论Kafka的架构和基本操作","categories":[{"name":"消息队列","slug":"消息队列","permalink":"https://www.yusp-spin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[]},{"title":"Redis cluster集群模式介绍","slug":"关于redisCluster","date":"2020-12-31T12:55:34.000Z","updated":"2021-01-03T04:29:35.049Z","comments":true,"path":"2020/12/31/关于redisCluster/","link":"","permalink":"https://www.yusp-spin.github.io/2020/12/31/%E5%85%B3%E4%BA%8EredisCluster/","excerpt":"","text":"一、Redis主从概念​ 为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。 ​ 在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。 二、为什么要有集群？​ redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。 三、数据分布算法3.1 hash算法​ 哈希算法的思想非常简单，也许你知道 HashMap 的哈希函数，哈希算法跟 HashMap 一样，也是通过一个哈希函数得到某一个数字，然后根据数字找到相应的服务器。 ​ 比如有N个redis实例，那么如何将key映射到redis上呢？ ​ 通常是采用hash算法计算key的hash值，然后通过取模，均匀的映射到N个redis服务器上，如果增加一个服务器，那么映射公式就变成了hash(key)%(N+1)，如果有一个服务器宕机了，映射公式变成了hash(key)%(N-1) ​ 这种情况下，几乎所有的缓存都失效了，会导致数据库访问的压力陡增，甚至导致数据库宕机 3.2 一致性hash算法​ 一致性哈希算法可以说是哈希算法的升级版，解决了哈希算法扩展性差的问题，一致性哈希算法跟哈希算法不一样，一致性哈希算法会将服务器和数据都通过哈希函数映射到一个首尾相连的哈希环上 具体步骤如下： 首先求出服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）上。 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。 可能存在的问题： ​ 一个master宕机不会导致大部分缓存失效，可能存在缓存热点问题 ，比如某个区间的值特别多没那么会导致大量的数据都涌入一个服务器内，造成缓存热点问题，出现性能瓶颈 3.3 用虚拟节点改进的一致性hash算法​ 缓存热点问题是在服务器节点数非常少的时候容易出现，因此，我们通过添加虚拟节点的方式，来使的服务器节点数变多，从而大量数据均匀分布，而不是涌入到一个服务器内 3.4 rediscluster的hash slot算法​ redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot 。hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去 ​ 客户端的api，可以对指定的数据，让他们走同一个hash slot，通过hash tag来实现 ​ 客户端向节点发送键命令，节点要计算这个键属于哪个槽。如果是自己负责这个槽，那么直接执行命令，如果不是，向客户端返回一个MOVED错误，指引客户端转向正确的节点。 四、节点间的通信机制1.基础通信 （1）redis cluster节点间采取gossip协议进行通信 跟集中式不同，不是将集群元数据（节点信息，故障，等等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的 集中式：好处在于，元数据的更新和读取，时效性非常好，一旦元数据出现了变更，立即就更新到集中式的存储中，其他节点读取的时候立即就可以感知到; 不好在于，所有的元数据的跟新压力全部集中在一个地方，可能会导致元数据的存储有压力 gossip：好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力; 缺点，元数据更新有延时，可能导致集群的一些操作会有一些滞后 （2）10000端口 每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口 每隔节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping之后返回pong （3）交换的信息 故障信息，节点的增加和移除，hash slot信息，等等 2. gossip协议 meet: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信 ping: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据 每个节点每秒都会频繁发送ping给其他的集群，ping，频繁的互相之间交换数据，互相进行元数据的更新 pong: 返回ping和meet，包含自己的状态和其他信息，也可以用于信息广播和更新 fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了 五、redis cluster 的高可用与主备切换原理redis cluster 的高可用的原理，几乎跟哨兵是类似的。 5.1 判断节点宕机如果一个节点认为另外一个节点宕机，那么就是 pfail，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 fail，客观宕机，跟哨兵的原理几乎一样，sdown，odown。 在 cluster-node-timeout 内，某个节点一直没有返回 pong，那么就被认为 pfail。 如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中，ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail。 5.2 从节点过滤对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。 检查每个 slave node 与 master node 断开连接的时间，如果超过了 cluster-node-timeout * cluster-slave-validity-factor，那么就没有资格切换成 master。 5.3 从节点选举每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。 所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node（N/2 + 1）都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。 从节点执行主备切换，从节点切换为主节点。 5.4 与哨兵比较整个流程跟哨兵相比，非常类似，所以说，redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。 参考部分文字参考链接：https://www.nowcoder.com/discuss/364714?type=post&amp;order=time&amp;pos=&amp;page=0 图片为作者所绘制，不存在参考","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.yusp-spin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.yusp-spin.github.io/tags/Redis/"}]},{"title":"TopK问题用快排和堆排的复杂度分别是多少？","slug":"TopK问题用快排和堆排的复杂度分别是多少？","date":"2020-12-21T02:22:56.000Z","updated":"2020-12-21T03:12:38.528Z","comments":true,"path":"2020/12/21/TopK问题用快排和堆排的复杂度分别是多少？/","link":"","permalink":"https://www.yusp-spin.github.io/2020/12/21/TopK%E9%97%AE%E9%A2%98%E7%94%A8%E5%BF%AB%E6%8E%92%E5%92%8C%E5%A0%86%E6%8E%92%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E5%88%AB%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F/","excerpt":"","text":"关于TopK问题TopK问题就是在一堆数据里面找到前 K 大(当然也可以是前 K 小)的数 常规方法，完全排序先完全排序后取topK，这种方法需要将数据完全排序，不适用于大数据量 利用快排3.1 解决思路借鉴快排的思想，在patiton中数组会分为三个部分，我们只要与index相比较就可以得出TopK是在左边部分还是右边部分，因此不需要全部排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Solution &#123; //要求的第k个数 int k; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; GetLeastNumbers(int [] input, int k) &#123; if (input.length &lt; k || k &lt; 1) &#123; return res; &#125; this.k = k; quick_sort(input, 0, input.length - 1); return res; &#125; private void quick_sort(int[] arr, int l, int r) &#123; if(l &gt; r) &#123; return ; &#125; int index = patiton(arr, l, r); //此处判断就是为了变成局部排序 if(index == k - 1) &#123; for (int i = 0; i &lt;= index; i++) &#123; res.add(arr[i]); &#125; return; &#125;else if(index &gt;= k) &#123; quick_sort(arr, l ,index - 1); &#125;else &#123; quick_sort(arr, index + 1, r); &#125; &#125; private int patiton(int[] arr, int l, int r) &#123; int tmp=arr[l]; while(l&lt;r)&#123; while(l&lt;r&amp;&amp;arr[r]&gt;=tmp)&#123; r--; &#125; arr[l]=arr[r]; while (l&lt;r&amp;&amp;arr[l]&lt;=tmp)&#123; l++; &#125; arr[r]=arr[l]; &#125; arr[l]=tmp; return l; &#125;&#125; 3.2 复杂度分析​ 与快排完全排序不同，每次分割后的数组大小近似为原数组大小的一半，因此这种方法的时间复杂度实际上是O(N)+O(N/2)+O(N/4)+……＜O(2N)，因此时间复杂度为**O(N)**，但是这种方法需要提前将N个数读入，对于海量数据来说，对空间开销很大 堆排序法4.1 解决思路​ 先随机取出N个数中的K个数，将这N个数构造为小顶堆，那么堆顶的数肯定就是这K个数中最小的数了，然后再将剩下的N-K个数与堆顶进行比较，如果大于堆顶，那么说明该数有机会成为TopK，就更新堆顶为该数，此时由于小顶堆的性质可能被破坏，就还需要调整堆 123456789101112131415161718192021222324252627282930public class Solution &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if (input.length &lt; k || k &lt; 1) &#123; return res; &#125; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; public int compare(Integer a, Integer b) &#123; return b - a; &#125; &#125;); int len = input.length; if(len &lt; k || k &lt; 1) &#123; return res; &#125; for(int i = 0; i &lt; len; i++) &#123; if(queue.size() &lt; k) &#123; queue.add(input[i]); &#125;else &#123; if(queue.peek() &gt; input[i]) &#123; queue.poll(); queue.add(input[i]); &#125; &#125; &#125; return new ArrayList&lt;&gt;(queue); &#125;&#125; 4.2 复杂度分析​ 首先需要对K个元素进行建堆，时间复杂度为O(k)，然后要遍历数组,最坏的情况是，每个元素都与堆顶比较并排序，需要堆化n次 所以是O(nlog(k))，因此总复杂度是O(k+nlog(k)); 5.小结​ 快排和堆排解决topK问题的复杂度其实面试中有被问过，有不少面试者直接答的快排和堆排的复杂度，但其实是不一样的，在TopK问题中，快排和堆排的复杂度分别问O(n)和O(k+nlog(k)) ​ 通过对比可以发现，堆排的优势是只需读入K个数据即可，可以实现来一个数据更新一次，能够很好的实现数据动态读入并找出TopK。","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"TopK","slug":"TopK","permalink":"https://www.yusp-spin.github.io/tags/TopK/"}]},{"title":"Redis常考的知识点","slug":"一文搞透Redis","date":"2020-12-01T13:44:12.000Z","updated":"2020-12-01T14:33:59.285Z","comments":true,"path":"2020/12/01/一文搞透Redis/","link":"","permalink":"https://www.yusp-spin.github.io/2020/12/01/%E4%B8%80%E6%96%87%E6%90%9E%E9%80%8FRedis/","excerpt":"","text":"一、Redis是什么，有什么功能？​ Redis 是一个使用 C 语言开发的数据库，也是一种Key-Value数据库,数据存储在内存中，常用作缓存数据库，速度较快。 功能：常用来作缓存，分布式锁，消息队列，排行榜等功能 二、Redis 和 Memcached 的对比 Memcached 只支持String类型，Reids支持更为丰富的数据类型 Redis支持数据的持久化 Redis的速度更快 Memcached 是多线程，非阻塞IO复用的网络模型，Redis使用单线程的IO复用 相同点就是都是内存型数据库，都有过期策略，性能都不错，常用来做缓存 ​ 三、Redis支持的数据类型以及底层数据结构 ​ string，底层数据结构为简单动态字符串（simple dynamic string，SDS），SDS 可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,此外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。 list，底层数据结构是链表，C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，获取表头表尾和链表长度都是O(1)复杂度 set，是一种无序集合，集合中的元素没有先后顺序。需要存储一个列表数据，又不希望出现重复时，可以选择set，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口 hash，底层是字典结构，字典在Redis中广泛被使用，包括数据库和哈希键，每个字典有两个哈希表，哈希表使用的是链地址法解决哈希冲突，扩容时采用的是渐进式哈希 Zset ，有点像是 Java 中 HashMap 和 TreeSet 的结合体，底层使用跳表实现 四、Redis为什么是单线程？​ Redis核心就是我所有数据都在内存里，单线程操作效率就是最高的，为什么要多线程呢？多线程会有一个代价，就是上下文切换，对于当个CPU绑定一块内存的数据，没有上下文切换就是效率最高的；相反，如果是多次磁盘IO的话，多线程更优，因为在寻道和选择的时间，线程在阻塞的等待磁盘，这个时间CPU可以去处理其他线程。 ​ 总之就是CPU不是redis的瓶颈，reids的瓶颈是机器内存和网络带宽，而单线程既不会成为瓶颈，又容易实现，那肯定单线程。 五、Redis是单线程吗？​ 将第五题和第四题放在一起就是为了分辨一个大部分人的误区，大家称Redis是单线程，但是Redis并不是单线程，比如持久化的时候就会fork子线程，包括网络IO也不是单线程，Redis的单线程指的是事件处理模型的单线程。 ​ Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler），通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。 ​ 文件事件处理器（file event handler）主要是包含 4 个部分： 多个 socket（客户端连接） IO 多路复用程序（支持多个客户端连接的关键） 文件事件分派器（将 socket 关联到相应的事件处理器） 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） 六、什么是缓存雪崩，什么是缓存穿透？​ 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。 ​ 解决方案就是： ​ 设置缓存添加随机过期时间，防止大量缓存同时失效 采用Reids高可用架构比如主从或者Redis Cluster，避免Redis挂掉 及时利用本地缓存和限流，防止下游数据库崩溃 开启持久化，重启后快速恢复数据 ​ 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大 ​ 解决方案就是： 访问一个不存在的参数时，将这个结果进行缓存，下次直接返回null 使用布隆过滤器进行过滤 七、Redis的过期键的删除策略 ​ 惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。 ​ 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。 八、Redis的内存淘汰机制​ Redis 提供 6 种数据淘汰策略： volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 4.0 版本后增加以下两种： volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key 九、Reids和数据库的双写一致性​ a. 先更新数据再更新缓存的话是不行的，更新结束，更新缓存失败岂不是gg ​ b. 先删缓存再更新数据库看起来可以，实际上也有问题： ​ i. A删缓存，B拿旧数据，放到缓存里，A更新数据库，就出问题了 ​ ii. 解决方案：延时双删（但是第二次删除还是会出现不一致问题），（要设置过期时间，保证最终一致性） ​ c. 先更新数据库再删缓存 ​ i. 问题：缓存刚好失效，然后A拿到旧数据，然后B更新缓存删缓存，A把旧数据放到数据库，但是碰上缓存刚好失效的概率比较低 十、Redis的持久化方式​ 快照（snapshotting）持久化（RDB）：Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。快照持久化是 Redis 默认采用的持久化方式 ​ AOF（append-only file）持久化：与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启 十一、Redis的渐进式扩容​ 每个字典有两个哈希表，一个ht[0],一个ht[1]，扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面。如果哈希表里保存的键值对数量非常大， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。为了避免此情况，所以采用渐进式哈希。 ​ 哈希表渐进式 rehash 的详细步骤： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1， 表示 rehash 操作已完成。 在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。 另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作 十二、Redis分布式锁（后续会有单独文章）​ 方法一：SETNX key value ​ 将 key 的值设为 value，当且仅当 key 不存在。​ 若给定的 key 已经存在，则 SETNX 不做任何动作。​ SETNX 是SET if Not eXists的简写 ​ 方法二（Redlock算法）： ​ 起 5 个 master 节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作： 得到当前的时间，微秒单位 尝试顺序地在 5 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个 client 需要合理设置与 master 节点沟通的 timeout 大小，避免长时间和一个 fail 了的节点浪费时间 当 client 在大于等于 3 个 master 上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。 如果锁申请到了，那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间 如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态 后续将会推送Reids集群的知识，敬请期待！","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.yusp-spin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.yusp-spin.github.io/tags/Redis/"}]},{"title":"Netty—心跳机制","slug":"Netty—心跳机制","date":"2020-11-30T03:42:36.000Z","updated":"2020-11-30T03:54:08.763Z","comments":true,"path":"2020/11/30/Netty—心跳机制/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/30/Netty%E2%80%94%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/","excerpt":"","text":"一、Netty心跳机制​ Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序 ​ 在Netty中，服务端启动后，等待客户端连接，客户端连接之后，向服务端发送消息。如果客户端在发送，那么服务端必定会收到数据，如果客户端停止发送消息，那么服务端就接收不到这个客户端的消息，既然客户端闲下来了，那么连接资源就是一种浪费，所以服务端检测到一定时间内客户端不活跃的时候，将客户端连接关闭。 二、心跳实现 可以使用TCP协议层的Keeplive机制，但是该机制默认的心跳时间是2小时，依赖操作系统实现不够灵活； 另一种就是，应用层实现自定义心跳机制，比如Netty实现心跳机制； 三、IdleStateHandler心跳检测​ pipeline.addLast(new IdleStateHandler(60,45,20, TimeUnit.SECONDS))指的是60s读空闲，45写空闲，20s读写空闲就触发对应userEventTriggered()方法 四、代码实现Server.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import com.netty.constants.Constants;import com.netty.factory.ZookeeperFactory;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.handler.timeout.IdleStateHandler;import org.apache.curator.framework.CuratorFramework;import org.apache.zookeeper.CreateMode;import java.net.InetAddress;import java.util.concurrent.TimeUnit;public class NettyServer &#123; public static void main(String[] args) &#123; ServerBootstrap bootstrap = new ServerBootstrap(); EventLoopGroup parentGroup = new NioEventLoopGroup(); EventLoopGroup childGroup = new NioEventLoopGroup(); try &#123; bootstrap.group(parentGroup, childGroup) .option(ChannelOption.SO_BACKLOG, 128) .childOption(ChannelOption.SO_KEEPALIVE, false)//自己写心跳包 .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); //实现心跳机制 pipeline.addLast(new IdleStateHandler(60,45,20, TimeUnit.SECONDS)); pipeline.addLast(new SimpleServerHandler()); &#125; &#125;); ChannelFuture sync = bootstrap.bind(8088).sync(); sync.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; parentGroup.shutdownGracefully(); childGroup.shutdownGracefully(); &#125; &#125;&#125; ServerHandler.java 1234567891011121314151617181920212223242526272829import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.handler.timeout.IdleState;import io.netty.handler.timeout.IdleStateEvent;public class SimpleServerHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println(msg); ctx.channel().writeAndFlush(&quot;is ok\\r\\n&quot;); ctx.channel().close(); &#125; @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123; if(evt instanceof IdleStateEvent) &#123; IdleStateEvent event = (IdleStateEvent)evt; if(event.state().equals(IdleState.READER_IDLE)) &#123; System.out.println(&quot;读空闲==&quot;); ctx.channel().close(); &#125;else if(event.state().equals(IdleState.WRITER_IDLE)) &#123; System.out.println(&quot;写空闲==&quot;); &#125;else if(event.state().equals(IdleState.ALL_IDLE)) &#123; System.out.println(&quot;读写空闲==&quot;); ctx.channel().writeAndFlush(&quot;ping\\r\\n&quot;); &#125; &#125; &#125;&#125; Client.java 1234567891011121314151617181920212223242526272829303132333435363738394041import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.util.AttributeKey;public class NettyClient &#123; public static void main(String[] args) &#123; String host = &quot;localhost&quot;; int port = 8088; EventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.SO_KEEPALIVE, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new StringEncoder()); ch.pipeline().addLast(new StringDecoder()); ch.pipeline().addLast(new SimpleClientHandler()); &#125; &#125;); ChannelFuture f = bootstrap.connect(host, port).sync(); f.channel().writeAndFlush(&quot;hello, server&quot;); f.channel().writeAndFlush(&quot;/r/n&quot;); f.channel().closeFuture().sync(); Object result = f.channel().attr(AttributeKey.valueOf(&quot;ssssss&quot;)).get(); System.out.println(&quot;获取到服务器返回的数据：&quot; + result); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; group.shutdownGracefully(); &#125; &#125;&#125; ClientHandler.java 12345678910111213141516package com.netty.client;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.AttributeKey;public class SimpleClientHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; if(&quot;ping&quot;.equals(msg.toString())) &#123; ctx.channel().writeAndFlush(&quot;pong\\r\\n&quot;); return; &#125; System.out.println(msg.toString()); &#125; 五、总结​ 使用 Netty 实现心跳机制的关键就是利用 IdleStateHandler 来产生对应的 idle 事件. ​ 对应userEventTriggered()方法来触发对应的idle事件处理","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/tags/Netty/"}]},{"title":"pagehelper的使用方法","slug":"pagehelper的使用方法","date":"2020-11-27T02:55:54.000Z","updated":"2020-11-27T04:08:37.818Z","comments":true,"path":"2020/11/27/pagehelper的使用方法/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/27/pagehelper%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、介绍现在一般springboot，mybatis项目中的mapper，pojo都是通过逆向工程直接生成的，但是生成的mapper中的查询语句中是没有分页功能的，如果想要分页的话，只能自己再去xml配置文件中修改sql语句，显得特别麻烦。为了方便快捷的翻页，这里引入一个分页插件。 pagehelper，原理如下 使用这个插件后，会自动在我们的sql查询中加上limit，而不需要我们自己再去做limit处理 二、使用方法​ 首先引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt;&lt;/dependency&gt; ​ 然后再在yml文件中配置 12345#pagehelper配置pagehelper: reasonable: true support-methods-arguments: true params: count=countSql 使用的时候只需要在我们的查询使用之前加上一句就行 ​ PageHelper.startPage(pageNum,pageSize); ​ pageNum是显示第几页；pageSize是每页的记录数 1234567@ResponseBody @RequestMapping(&quot;/list&quot;) public List&lt;TbItem&gt; selectAll() &#123; PageHelper.startPage(1,10); List&lt;TbItem&gt; tbItems = tbItemService.selectAll(); return tbItems; &#125; 注意：查询语句必须紧跟在PageHelper.startPage(pageNum,pageSize);语句之后，不然分页会有问题。 为了方便，我们通常创建一个PageInfo的对象，从对象中获取分页信息 12345678@ResponseBody @RequestMapping(&quot;/list&quot;) public PageInfo&lt;TbItem&gt; selectAll() &#123; PageHelper.startPage(1,10); List&lt;TbItem&gt; tbItems = tbItemService.selectAll(); PageInfo&lt;TbItem&gt; pageInfo = new PageInfo&lt;&gt;(tbItems); return pageInfo; &#125;","categories":[{"name":"框架","slug":"框架","permalink":"https://www.yusp-spin.github.io/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"设计模式—创建型模式","slug":"设计模式—创建型模式","date":"2020-11-22T14:41:13.000Z","updated":"2021-01-03T03:30:16.242Z","comments":true,"path":"2020/11/22/设计模式—创建型模式/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1.什么是创建型模式？​ 创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new直接去实例化对象，这使得程序在创建对象时更加灵活和有针对性 ​ 主要包括 单例模式，工厂模式，抽象工厂模式，建造者模式等 2.单例模式单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式 单例模式有 3 个特点： 单例类只有一个实例对象； 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Singleton &#123;&#125;//懒汉式class LazySingleton &#123; private static volatile LazySingleton instance ; private LazySingleton() &#123;&#125; public static synchronized LazySingleton getInstance() &#123; if(instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125;//饿汉式class HungrySingleton &#123; private static HungrySingleton instance = new HungrySingleton(); private HungrySingleton () &#123;&#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125;//双重校验锁class DoubleSingleton &#123; private static volatile DoubleSingleton instance; private DoubleSingleton ()&#123;&#125; public static DoubleSingleton getInstance() &#123; if (instance == null) &#123; synchronized (DoubleSingleton.class) &#123; if (instance == null) &#123; instance = new DoubleSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 3.简单工厂模式 我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。 在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。 简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。 简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。 “工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。 123public interface Computer &#123; void start();&#125; 123456public class AsusComputer implements Computer &#123; @Override public void start() &#123; System.out.println(&quot;华硕电脑启动&quot;); &#125;&#125; 123456public class HpComputer implements Computer &#123; @Override public void start() &#123; System.out.println(&quot;惠普电脑启动&quot;); &#125;&#125; 123456public class LenovoComputer implements Computer&#123; @Override public void start() &#123; System.out.println(&quot;联想电脑启动&quot;); &#125;&#125; 123456789101112131415161718public class SimpleFactory &#123; public static Computer createComputer (String type) &#123; Computer computer = null; switch (type) &#123; case &quot;lenovo&quot; : computer = new LenovoComputer(); break; case &quot;hp&quot;: computer = new HpComputer(); break; case &quot;asus&quot;: computer = new AsusComputer(); break; &#125; return computer; &#125;&#125; 12345public class test &#123; public static void main(String[] args) &#123; SimpleFactory.createComputer(&quot;hp&quot;).start(); &#125;&#125; 4.工厂方法模式​ 工厂方法模式（Factory Method Pattern）：又称为工厂模式或者多态工厂模式。在 *工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具 * 体的产品对象，这样做的目的是将产品的实例化操作延迟到工厂子类中完成，即通过工厂 * 子类来确定究竟应该实例化哪一个具体产品类。 123public interface MachineApi &#123; void process (String material);&#125; 123456public class BoodleMachine implements MachineApi&#123; @Override public void process(String material) &#123; System.out.println(&quot;我把&quot; + material + &quot;加工成了面条&quot;); &#125;&#125; 123456public class SteamedBunMachine implements MachineApi&#123; @Override public void process(String material) &#123; System.out.println(&quot;我把&quot; + material + &quot;加工成了馒头&quot;); &#125;&#125; 12345678public abstract class Factory &#123; public abstract MachineApi newMachine(); public void process (String material) &#123; MachineApi machine = newMachine(); machine.process(material); &#125;&#125; 123456public class NoodleFactory extends Factory &#123; @Override public MachineApi newMachine() &#123; return new BoodleMachine(); &#125;&#125; 123456public class SteamedBunFactory extends Factory &#123; @Override public MachineApi newMachine() &#123; return new SteamedBunMachine(); &#125;&#125; 12345678910public class test &#123; public static void main(String[] args) &#123; Factory factory1 = new SteamedBunFactory (); factory1.process(&quot;面粉&quot;);//我把面粉加工成了馒头 Factory factory2 = new NoodleFactory (); factory2.process(&quot;米粉&quot;);//我把面粉加工成了馒头 &#125;&#125; 5.抽象工厂模式​ 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 123public interface Shape &#123; void draw();&#125; 1234567public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125; 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125; 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 123public interface Color &#123; void fill();&#125; 1234567public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125; 1234567public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125; 1234567public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125; 1234public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;&#125; 12345678910111213141516171819202122public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125; 12345678910111213141516171819202122public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125; 12345678910public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;Green&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 三大工厂模式的区别可见： ​ www.zhihu.com/question/20367734/answer/807965357 6.建造者模式​ 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 参考：https://www.runoob.com/design-pattern","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.yusp-spin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.yusp-spin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot 必须依赖spring-boot-parent？","slug":"springboot如何不依赖parent","date":"2020-11-21T13:27:47.000Z","updated":"2020-11-21T13:31:35.098Z","comments":true,"path":"2020/11/21/springboot如何不依赖parent/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/21/springboot%E5%A6%82%E4%BD%95%E4%B8%8D%E4%BE%9D%E8%B5%96parent/","excerpt":"","text":"在做项目的时候遇到一个问题问题做项目的时候遇到一个问题 子moudle的pom中已经引用了为父moudle,但是springboot项目又需要引用spring-boot-start-parent，但是同时引用两个的话pom文件会报错，于是我们 翻看了官方文档已经查阅资料发现，可以不用,直接引包亦可以实现同样的功能，SpringBoot 不是必须依赖spring-boot-parent。 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;","categories":[{"name":"SpringBoot 框架","slug":"SpringBoot-框架","permalink":"https://www.yusp-spin.github.io/categories/SpringBoot-%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"常见排序介绍及优化手段","slug":"常见排序介绍及优化手段","date":"2020-11-16T05:42:47.000Z","updated":"2020-11-16T06:28:33.000Z","comments":true,"path":"2020/11/16/常见排序介绍及优化手段/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/16/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/","excerpt":"","text":"1.插入排序123456789101112131415public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //插入排序：每次将当前元素插入到左侧已经排好的数组中 int len=arr.length; for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt;0; j--) &#123; if(arr[j]&lt;arr[j-1])&#123; int tmp=arr[j]; arr[j]=arr[j-1]; arr[j-1]=tmp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 2. 堆排序123456789101112131415161718192021222324252627282930313233343536373839public class duipaixu &#123; public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //插入排序：每次将当前元素插入到左侧已经拍好的数组中 int len=arr.length; heap_sort(arr,len-1); System.out.println(Arrays.toString(arr)); &#125; private static void heap_sort(int[] arr,int len)&#123; //形成二叉堆 for (int i = (len-2)/2; i &gt;=0; i--) &#123; downadjust(arr,i,len+1); &#125; for(int i=len;i&gt;0;i--)&#123; int tmp=arr[i]; arr[i]=arr[0]; arr[0]=tmp; downadjust(arr,0,i); &#125; &#125; private static void downadjust(int[] arr,int parent,int len)&#123; int tmp=arr[parent]; int child=2*parent+1; while(child&lt;len)&#123; if(child+1&lt;len&amp;&amp;arr[child]&gt;=arr[child+1])&#123; child++; &#125; if(tmp&lt;=arr[child])&#123; break; &#125; arr[parent]=arr[child]; parent=child; child=2*parent+1; &#125; arr[parent]=tmp; &#125;&#125; 3. 归并排序1234567891011121314151617181920212223242526272829303132333435363738public class guibinpaixu &#123; public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //插入排序：每次将当前元素插入到左侧已经拍好的数组中 int len=arr.length; gbsort(arr,0,len-1); System.out.println(Arrays.toString(arr)); &#125; private static void gbsort(int[] arr,int l,int r)&#123; if(l&gt;=r)&#123; return; &#125; int mid=l+(r-l)/2; gbsort(arr,l,mid); gbsort(arr,mid+1,r); help(arr,l,mid,r); &#125; private static void help(int[] arr,int l,int mid,int r)&#123; int[] help=new int[r-l+1]; int p=l; int q=mid+1; int index=0; while(p&lt;=mid&amp;&amp;q&lt;=r)&#123; help[index++]=arr[p]&lt;arr[q]?arr[p++]:arr[q++]; &#125; while(p&lt;=mid)&#123; help[index++]=arr[p++]; &#125; while(q&lt;=mid)&#123; help[index++]=arr[q++]; &#125; for(int i=0;i&lt;index;i++)&#123; arr[i+l]=help[i]; &#125; &#125;&#125; 4. 快速排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class kuaipai &#123; public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //插入排序：每次将当前元素插入到左侧已经拍好的数组中 int len=arr.length; quick_sort(arr,0,len-1); System.out.println(Arrays.toString(arr)); &#125; private static void quick_sort(int[] arr,int l ,int r)&#123; if(l&gt;=r)&#123; return; &#125; int index=partition(arr,l,r); quick_sort(arr,l,index-1); quick_sort(arr,index+1,r); &#125; private static int partition(int[] arr,int l ,int r)&#123; int tmp=arr[l]; while(l&lt;r)&#123; while(l&lt;r&amp;&amp;arr[r]&gt;=tmp)&#123; r--; &#125; arr[l]=arr[r]; while (l&lt;r&amp;&amp;arr[l]&lt;=tmp)&#123; l++; &#125; arr[r]=arr[l]; &#125; arr[l]=tmp; return l; &#125;&#125;``````##### 5. 冒泡排序```javapublic static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //每次冒泡出一个结果到最后 int len=arr.length; for(int i=len-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;=i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 6. 希尔排序12345678910111213141516171819202122public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //插入排序：每次将当前元素插入到左侧已经拍好的数组中 int len=arr.length; int h=1; while(h&lt;len/3)&#123; h=h*3+1; &#125; while(h&gt;=1)&#123; for(int i=h;i&lt;len;i++)&#123; for(int j=i;j&gt;=h;j-=h)&#123; if(arr[j]&lt;arr[j-h])&#123; int tmp=arr[j]; arr[j]=arr[j-h]; arr[j-h]=tmp; &#125; &#125; &#125; h/=3; &#125; System.out.println(Arrays.toString(arr));&#125; 7. 选择排序1234567891011121314151617public static void main(String[] args) &#123; int[] arr=&#123;7,4,87,23,2324,57,34,87,345,68,23,1,567,345,77,33,2,1,1,76&#125;; //选择排序，每次选择一个最小的与前面的交换 int len=arr.length; for (int i = 0; i &lt; len-1; i++) &#123; int min=i; for (int j = i+1; j &lt;len ; j++) &#123; if(arr[min]&gt;arr[j])&#123; min=j; &#125; &#125; int tmp=arr[min]; arr[min]=arr[i]; arr[i]=tmp; &#125; System.out.println(Arrays.toString(arr)); &#125; 各大排序优化：冒泡：加入一个flag，如果有一轮flag没变说明没排序，说明已经排序好，可以直接退出快排：小数组切换到插入排序，三数取中，三向切分 三向切分：类似于荷兰国旗改进，荷兰国旗问题和经典快排不同的就只是将&lt;=num改为了&lt; num和=num两部分，借用这个思想使得原来每次只可以让一个数找到正确的位置改进为了每次至少让一个数找到位置 在topk问题中，快排每次可以排除一半元素 随机快排 1. 选取最后一个数：如果是一个已经排好序的数组，每次找到位置之后，左边是要进行排序的部分，数组长度是原长度-1，它的时间复杂度就是O(N^2)；如果每次找到的数都是中间的位置，它的时间复杂度就只有O(logN) 2. 然而以随机数作为选取的标准num的时候，因为是随机的，就只能通过数学期望去计算它的时间复杂度，时间复杂度是O(logN)","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"了解ConcurrentHashMap","slug":"了解ConcurrentHashMap","date":"2020-11-15T02:09:01.000Z","updated":"2020-11-15T02:36:32.329Z","comments":true,"path":"2020/11/15/了解ConcurrentHashMap/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/15/%E4%BA%86%E8%A7%A3ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap中没有负载因子和阈值吗 是没有，改用了sizeCtl控制，0表示默认值，-1表示正在扩容，&gt;0表示下一次扩容的门槛，-（1+nThreads）n个线程正在扩容，sizeCtl的变化都是CAS操作 sizeCtl： （1）-1，表示有线程正在进行初始化操作 （2）-(1 + nThreads)，表示有n个线程正在一起扩容 （3）0，默认值，后续在真正初始化的时候使用默认容量 （4）&gt; 0，初始化或扩容完成后下一次的扩容门槛 1234567891011121314151617181920212223242526272829303132public ConcurrentHashMap() &#123;&#125;public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125;public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.sizeCtl = DEFAULT_CAPACITY; putAll(m);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, 1);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap;&#125; 请讲讲ConcurrentHashMap的put操作？ a. 控制key和value都不能为null b. 再用自旋+cas实现put过程，下面是具体的put c. 如果桶未初始化就初始化桶 d. 如果桶中还没有元素就把这个元素插进去，插入这一步就是采用的CAS e. 如果要插入的桶正在扩容迁移元素，就当前线程一起帮忙协助扩容 f. 如果桶已经存在且没有迁移元素 g. 就锁住这个桶，是采用分段锁的思想（锁住后里面不需要cas） h. 如果元素存在就替换，不存在size+1，插到链表或者树的尾部 i. 如果桶的元素个数达到了8就尝试树化 j. 元素个数+1（分段锁思想），同时检查是否需要扩容k. 返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Maps the specified key to the specified value in this table. * Neither the key nor the value can be null. * * &lt;p&gt;The value can be retrieved by calling the &#123;@code get&#125; method * with a key that is equal to the original key. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &#123;@code key&#125;, or * &#123;@code null&#125; if there was no mapping for &#123;@code key&#125; * @throws NullPointerException if the specified key or value is null */ public V put(K key, V value) &#123; return putVal(key, value, false); &#125; /** Implementation for put and putIfAbsent */ final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null; &#125; 请讲讲ConcurrentHashMap的扩容操作？ 初始化桶操作：判断是否正在扩容，正在的话就让出cpu。否则就用CAS更新sizeCtl（CAS控制只有一个线程初始化桶数组），设置容量，并设置扩容门槛（写死的）赋值给sizeCtl addCount操作，元素数量+1，并会判断是否需要扩容，这里是数组数量采用分段锁的思想，根据不同线程存储到不同段上, 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上（采用CAS添加）,如果不同线程对应的分段都添加失败，就要扩容段 扩容：sizeCtl存储着扩容门槛，高位存储扩容邮戳，低位存储存储着扩容线程数加1，即1+nThreads),sc小于0，说明正在扩容，就当前线程加入到迁移元素中去，扩容线程+1；如果没有线程在扩容，自己就扩容，加入迁移元素，sizeCtl低位为2（1+nThreads） 协助扩容：线程添加元素时发现正在扩容且当前元素所在的桶元素已经迁移完成了，则协助迁移其它桶的元素。迁移完成的标志：如果桶数组不为空，并且当前桶第一个元素为ForwardingNode类型，并且nextTab不为空 迁移元素：扩容时容量变为两倍，并把部分元素迁移到其它桶中。迁移元素先从靠后的桶开始；迁移完成的桶在里面放置一ForwardingNode类型的元素，标记该桶迁移完成； 过程：迁移元素是用sychronized锁住该桶，迁移的时候，根据迁移时根据hash&amp;n是否等于0把桶中元素分化成两个链表或树；等于0的在原来的位置，不等于0 就在原来的位置+n,(n的扩大的大小) 添加元素： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Adds to count, and if table is too small and not already * resizing, initiates transfer. If already resizing, helps * perform transfer if work is available. Rechecks occupancy * after a transfer to see if another resize is already needed * because resizings are lagging additions. * * @param x the count to add * @param check if &lt;0, don&#x27;t check resize, if &lt;= 1 only check if uncontended */ private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125; &#125; 协助扩容： 1234567891011121314151617181920212223/** * Helps transfer if a resize is in progress. */ final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table; &#125; 迁移元素： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. */ private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(&quot;unchecked&quot;) Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125; &#125; 删除流程：a. 删除元素跟添加元素一样，都是先找到元素所在的桶，然后采用分段锁的思想锁住整个桶，再进行操作。b. 流程：进入自旋，如果正在扩容，协助扩容，如果没有，对桶加锁，找到元素，删除，如果是树退化成链表，还要进行退化操作，删除了元素，就元素个数-1；返回旧值，没有删除元素就返回null 获取元素：a. 不加锁，b. 所以ConcurrentHashMap不是强一致性的‘ Jdk1.7和1.8的区别，底层数据结构有什么不同，put和get操作的不同a. 数据结构差别：JDK1.7中ConcurrentHashMap采用了数组+Segment+分段锁，segment继承自ReentrantLock，缺点：需要两次hash，hash时间长。优点：并发能力高，segment之间相互不影响；JDK1.8中，数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作b. 数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。c. 保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。d. 锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。e. 链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。f. 查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.yusp-spin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"操作系统-存储器管理","slug":"操作系统-存储器管理","date":"2020-11-14T14:25:43.000Z","updated":"2020-11-14T13:11:40.819Z","comments":true,"path":"2020/11/14/操作系统-存储器管理/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"1.概述​ 存储器管理涉及一下五个功能： ​ 1. 存储器分配，主要解决多道程序和多程序如何共享主存的问题 ​ 2. 地址转换和重定位，研究各种地址变换方法及相应的地址变换机构 ​ 3. 存储器保护 ​ 4. 存储器扩充 ​ 5. 存储器共享 地址空间：程序限定的空间叫逻辑地址空间，其中的地址叫做相对地址或逻辑地址 存储空间：存储空间是物理存储器中全部物理单元的集合所限定的空间，由字或字节组成的大大的阵列，每个字和字节有自己的编号。 地址重定位： 链接 链接就是将汇编/编译产生的一个或多个目标代码与所需要的库函数装配成一个可执行程序；链接有两种方式：静态和动态。采用静态链接时，在程序装入内存运行前，就将目标模块和库事先连接成可执行程序；动态链接分为装入和运行时两种，装入就是指将目标模块装入主存时，边装入边链接，运行就是指运行时才链接。运行时链接的效率更高 静态重定位 在逻辑地址转换为物理地址的过程中，地址变换是在进程装入时一次完成的，以后不再改变。 优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机系统中大多采用这种方案。 缺点：内存空间不能移动；各个用户进程很难共享内存中同一程序的副本 动态重定位 动态运行的装入程序把转入模块装入内存之后，并不立即把装入模块的逻辑地址进行转换，而是把这 种地址转换推迟到程序执行时才进行，装入内存后的所有地址都仍是逻辑地址。这种方式需要寄存器的支持，其中 放有当前正在执行的程序在内存空间中的起始地址。 优点：内存空间可以移动；各个用户进程可以共享内存中同一程序的副本。 缺点：增加了机器成本，而且实现存储管理的软件算法比较复杂。 存储器保护 存储器分为两部分，一是操作系统占用区，另一部分是多用户进程分享的用户占用区。保护涉及两个方面：地址越界和存取方式的保护 存储器共享 2.单用户单道程序的存储器分配​ 单一连续区分配，整个系统资源利用率低 3.多用户多道程序存储器分配——分区分配​ 固定式分区、可变式分区 固定式分区​ 固定式分区是适合多到程序运行的最简单的存储器管理，把主存用户区预先划分为几个大小不等的区域，当进程到达时，选择一个合适进程要求最小的，空闲分区分给进程；没有合适的空闲分区的时候，让其等待。为了充分利用存储器，将进程按照请求空间的大小在不同分区排队等待。 ​ 这种方法管理简单，但有可能出现大分区队列空闲，小分区队列拥挤的现象。当这情况出现时，会使存储器造成更大的浪费，为了充分利用存储器，系统只维护一个存储器等待队列，任何时候，只要有一个分区变为空闲，队列中的一个进程就可装入运行 可变式分区​ 为了提高存储器的利用率，存储空间的划分推迟到装入进程时进行，当进程要求运行时，系统从空闲的存储空间划分出大小正好等于进程大小的一个存储区分配给进程，这叫做可变式分区或者动态分区，使用这种技术时，分区的大小和个数不断变化。 ​ 可变式分区能改进存储器的使用效率，但是却使存储的分配和释放工作复杂了 可变式分区管理使用的数据结构​ 1.分区说明表：由两张表格组成，一张是已分配区表，记录已分配给进程的分区情况；另一张是未分区表，记录主存空闲区的情况。 ​ 2.空闲区链：记录存储空间的一个较好方法就是表格信息附加在每个已分配取和未分配区中，通常将表格信息放在每个分区的首字或尾字中。已分配的信息放在各个进程的PCB表中，空闲区的信息用空闲链表管理 分区管理的地址重定位和存储器保护​ 固定式分区采用静态重定位，在装入的时候，上下界限两个寄存器来保护存储器，方式地址越界错误 ​ 可变式分区采用动态重定位，系统会设置一个基址（重定位）寄存器，存放运行进程分配的主存区起始地址，再增设一个限长寄存器，用来存放运行程序的大小，也是起到保护作用。 分区管理的优缺点​ 优点：实现了多道程序共享主存、实现分区管理的系统设计相对简单、实现存储器保护的手段也比较简单 ​ 缺点：主存利用不够充分、没有实现主存的扩充问题","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.yusp-spin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"Git常用命令","slug":"git常用命令","date":"2020-11-12T13:58:13.000Z","updated":"2020-11-12T14:01:50.753Z","comments":true,"path":"2020/11/12/git常用命令/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/12/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git常用操作总结一下，也相当于做个笔记 1、git 配置git config user.name 查看 用户名 git config user.email 查看 邮箱 git config –global user.name 修改 用户名 git config –global user.email 修改 邮箱 ssh-keygen -t rsa -C “ &#x79;&#x6f;&#117;&#x72;&#x5f;&#101;&#109;&#97;&#x69;&#x6c;&#x40;&#101;&#x78;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;“ 创建SSH key 【可以填写任意值作为注释key，例如邮箱】 ssh -T &#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#101;&#x65;&#46;&#x63;&#111;&#109; 测试该SHH key 已添加到 gitee.com【码云】 2、创建版本库git init 初始化本地版本库【创建一个 .git的子目录】 git init [project-name] 新建一个目录，并将其初始化为 git 代码库； git clone 克隆远程版本库； 3、修改和提交git status 显示文件的状态 【红色表示被修改没提交到暂存区，绿色代表已提交到暂存区；】 git status -s 以极简的方式显示文件的状态【红色的M 表示被修改没提交到暂存区，绿色的M代表已提交到暂存区；】 git add 将文件从工作目录添加至暂存区； git add -u | –update 仅将被修改的文件添加至暂存区（不包含新添加的文件）； git add . 将被修改的文件 和 新添加的文件提交到暂存区（不包含已经删除的文件）； git add -a 将本地所有修改的内容添加至暂存区（包含新添加的 和 已经删除的）； git commit 将暂存区的修改提交到本地仓库，同时生成一个commit-id； git commit -m 将暂存区修改提交到本地仓库 git commit -a -m 将工作区的修改提交到本地仓库 【相当于 git add + git commit 】 git commit -amend 修改上一次提交【代码没有任何变化，则修改提交信息】 4、分支操作git branch git branch 列出所有本地分支 git branch -r 列出所有远程分支 git branch -a 列出所有本地和远程分支 git branch [branch-name] 新建一个分支，仍停留在当前分支 git branch -m 将分支nameA 改名为 nameB git branch -d [branch-name] 删除分支 git checkout git checkout [branch-name] 切换到指定分支 git checkout -b [branch-name] 新建一个分支，并切换到该分支 git checkout - 切换到上一个分支 git merge git merge [branch-name] 合并指定分支到当前分支 5、远程操作git fetch 将远程主机上所有分支的更新取回本地，并记录在 .git/FETCH_HEAD 中； git fetch 下载远程仓库的所有变动； git fetch master:test 在本地新建test 分支，并将主机上master分支代码下载到本地 test 分支； git remote git remote -v 显示所有远程仓库 git remote show 显示某个远程仓库的信息 git remote add [ url ] 增加一个新的远程仓库 并命名 git pull git pull &lt;远程主机名&gt; &lt;远程分支名&gt; : &lt;本地分支名&gt; 取回远程仓库某个分支的更新，并与本地分支合并 git pull origin dev: master 取回远程主机的 dev 分支，与本地的master分支合并 git pull origin dev 相当于以下两个命令： git fetch origin 获取远程主机上所有分支的更新 git merge origin/dev 与当前分支合并 git push git push &lt;远程主机名&gt; &lt;本地分支名&gt; : &lt;远程分支&gt; 上传本地指定分支到远程仓库的指定分支 省略远程分支名，表示将本地分支推送到与之存在“追踪关系”的远程分支，通常两者同名，后者不存在，将会被创建； 省略本地分支名，表示删除指定的远程分支【这相当推送一个空的本地分支到远程分支】； git push origin master 将本地的master 分支推送到 origin 主机的master 分支【后者不存在，将会被创建】 git push origin : master 删除 origin 主机的master 分支；【相当于 git push origin –delete master】 6、撤销修改撤销工作区的修改： 【文件修改之后撤销】 git checkout – file 恢复暂存区的指定文件到工作区 git checkout . 恢复暂存区的所有文件到工作区 撤销暂存区的修改： 【git add 之后】 git reste HEAD 版本回退 ： git reset –hard git log 查看提交历史，确定回退到那个版本； git reflog 查看历史命令，确定回到未来的版本； 参考：https://www.cnblogs.com/james23dong/p/12375970.html","categories":[{"name":"Git","slug":"Git","permalink":"https://www.yusp-spin.github.io/categories/Git/"}],"tags":[]},{"title":"Netty介绍","slug":"Netty介绍","date":"2020-11-09T14:12:47.000Z","updated":"2020-11-09T14:12:28.184Z","comments":true,"path":"2020/11/09/Netty介绍/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/09/Netty%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一、什么是Netty​ Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序 ​ 也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 我们下面编写四个类 1.用于接收数据的服务器端Socket 2.用于接收客户端的消息，用于接收和反馈客户端发出的消息类ServertHandler 3.用于发送数据的服务器端Client 4.用于发送数据和接收服务器端发出的数据处理类ClientHandler Socket.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.DelimiterBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder; public class Server &#123; public static void main(String[] args) throws InterruptedException &#123; //1.第一个线程组是用于接收Client端连接的 EventLoopGroup bossGroup = new NioEventLoopGroup(); //2.第二个线程组是用于实际的业务处理的 EventLoopGroup workerGroup = new NioEventLoopGroup(); ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup);//绑定两个线程池 b.channel(NioServerSocketChannel.class);//指定NIO的模式，如果是客户端就是NioSocketChannel b.option(ChannelOption.SO_BACKLOG, 1024);//TCP的缓冲区设置 b.option(ChannelOption.SO_SNDBUF, 32*1024);//设置发送缓冲的大小 b.option(ChannelOption.SO_RCVBUF, 32*1024);//设置接收缓冲区大小 b.option(ChannelOption.SO_KEEPALIVE, true);//保持连续 b.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel sc) throws Exception &#123; ByteBuf buf = Unpooled.copiedBuffer(&quot;$_&quot;.getBytes());//拆包粘包定义结束字符串（第一种解决方案） sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf));//在管道中加入结束字符串 // sc.pipeline().addLast(new FixedLengthFrameDecoder(200));第二种定长 sc.pipeline().addLast(new StringDecoder());//定义接收类型为字符串把ByteBuf转成String sc.pipeline().addLast(new ServertHandler());//在这里配置具体数据接收方法的处理 &#125; &#125;); ChannelFuture future = b.bind(8765).sync();//绑定端口 future.channel().closeFuture().sync();//等待关闭(程序阻塞在这里等待客户端请求) bossGroup.shutdownGracefully();//关闭线程 workerGroup.shutdownGracefully();//关闭线程 &#125;&#125; 1.在上面这个Server.java中，我们都要定义两个线程池，boss和worker，boss是用于管理连接到server端的client的连接数的线程池，而woeker是用于管理实际操作的线程池。 2.ServerBootstrap用一个ServerSocketChannelFactory 来实例化。ServerSocketChannelFactory 有两种选择，一种是NioServerSocketChannelFactory，一种是OioServerSocketChannelFactory。 前者使用NIO，后则使用普通的阻塞式IO。它们都需要两个线程池实例作为参数来初始化，一个是boss线程池，一个是worker线程池。 3.然后使ServerBookstrap管理boss和worker线程池。并且设置各个缓冲区的大小。 4.这里的事件处理类经常会被用来处理一个最近的已经接收的Channel。ChannelInitializer是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel。也许你想通过增加一些处理类比如NettyServerHandler来配置一个新的Channel 或者其对应的ChannelPipeline来实现你的网络程序。 当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，然后提取这些匿名类到最顶层的类上。 5.在使用原始的encoder、decoder的情况下，Netty发送接收数据都是按照ByteBuf的形式，其它形式都是不合法的。 而在上面这个Socket中，我使用sc.pipeline().addLast()这个方法设置了接收为字符串类型，注意：只能设置接收为字符串类型，发送还是需要发送ByteBuf类型的数据。而且在这里我还设置了以$_为结尾的字符串就代表了本次请求字符串的结束。 6.通过b.bind绑定端口，用于监听的端口号。 ServerHandler.java 1234567891011121314151617public class ServertHandler extends ChannelHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; String body = (String) msg; System.out.println(&quot;server&quot;+body);//前面已经定义了接收为字符串，这里直接接收字符串就可以 //服务端给客户端的响应 String response= &quot; hi client!$_&quot;;//发送的数据以定义结束的字符串结尾 ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));//发送必须还是ByteBuf类型 &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; &#125; ServertHandler继承自 ChannelHandlerAdapter，这个类实现了ChannelHandler接口，ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承ChannelHandlerAdapter类而不是你自己去实现接口方法。 1.由于我们再server端开始的时候已经定义了接收类型为String，所以在这里我们接收到的msg直接强转成String就可以了。同时也要定义以什么为一次请求的结尾。 Client.java 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; EventLoopGroup worker = new NioEventLoopGroup(); Bootstrap b = new Bootstrap(); b.group(worker) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel sc) throws Exception &#123; ByteBuf buf = Unpooled.copiedBuffer(&quot;$_&quot;.getBytes()); sc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024,buf)); sc.pipeline().addLast(new StringDecoder()); sc.pipeline().addLast(new ClientHandler()); &#125; &#125;); ChannelFuture f=b.connect(&quot;127.0.0.1&quot;,8765).sync(); f.channel().writeAndFlush(Unpooled.copiedBuffer(&quot; hi server2$_&quot;.getBytes())); f.channel().writeAndFlush(Unpooled.copiedBuffer(&quot; hi server3$_&quot;.getBytes())); f.channel().writeAndFlush(Unpooled.copiedBuffer(&quot; hi server4$_&quot;.getBytes())); f.channel().closeFuture().sync(); worker.shutdownGracefully(); &#125;&#125; client端和Socket端几乎代码相同，只是client端用的不是ServerBootstrap而是Bootstrap来管理连接 ClientHandler.java 1234567891011121314151617public class ClientHandler extends ChannelHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; try &#123; System.out.println(&quot;client&quot;+msg.toString()); &#125; finally &#123; ReferenceCountUtil.release(msg);//释放缓冲区 &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; ClientHandler和ServertHandler代码和原理也是一样，只是在client端我们要释放缓冲区。为什么在ServerHandler我们不需要释放呢 ？因为在ServertHandler我们调用ctx.writeAndFlush方法的时候，这个方法默认已经帮我们释放了缓冲区。 参考：https://blog.csdn.net/a347911/article/details/53734255","categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/categories/Netty/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/tags/Netty/"}]},{"title":"Go-make和new关键字的区别和实现原理","slug":"Go-make和new关键字的区别和实现原理","date":"2020-11-08T13:32:47.000Z","updated":"2020-11-08T13:33:06.858Z","comments":true,"path":"2020/11/08/Go-make和new关键字的区别和实现原理/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/08/Go-make%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、简介​ make 和 new都用来初始化一个结构，make 关键字的主要作用是初始化内置的数据结构，也就是我们在前面提到的数组、切片和 Channel，而当我们想要获取指向某个类型的指针时可以使用 new 关键字 二、区别make在Go语言中用来初始化语言的基本类型 12345func main() &#123; slice := make([]int, 0, 100) myMap := make(map[string]int, 10) ch := make(chan int, 5)&#125; new 的作用其实只是接收一个类型作为参数然后返回一个指向这个类型的指针 123i := new(int)var v inti := &amp;v 所以：make 用于创建切片、哈希表和管道等内置数据结构，new 用于分配并创建一个指向对应类型的指针。 三、原理make ​ 在编译期间的类型检查阶段，Go语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。 new ​ 内置函数 new 会在编译期间的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject： 12345678910111213141516171819func callnew(t *types.Type) *Node &#123; if t.NotInHeap() &#123; yyerror(&quot;%v is go:notinheap; heap allocation disallowed&quot;, t) &#125; dowidth(t) if t.Size() == 0 &#123; z := newname(Runtimepkg.Lookup(&quot;zerobase&quot;)) z.SetClass(PEXTERN) z.Type = t return typecheck(nod(OADDR, z, nil), ctxExpr) &#125; fn := syslook(&quot;newobject&quot;) fn = substArgTypes(fn, t) v := mkcall1(fn, types.NewPtr(t), nil, typename(t)) v.SetNonNil(true) return v&#125; ​ 需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存： 123456789101112131415161718192021222324252627func walkstmt(n *Node) *Node &#123; switch n.Op &#123; case ODCL: v := n.Left if v.Class() == PAUTOHEAP &#123; if prealloc[v] == nil &#123; prealloc[v] = callnew(v.Type) &#125; nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v]) nn.SetColas(true) nn = typecheck(nn, ctxStmt) return walkstmt(nn) &#125; case ONEW: if n.Esc == EscNone &#123; r := temp(n.Type.Elem()) r = nod(OAS, r, nil) r = typecheck(r, ctxStmt) init.Append(r) r = nod(OADDR, r.Left, nil) r = typecheck(r, ctxExpr) n = r &#125; else &#123; n = callnew(n.Type.Elem()) &#125; &#125;&#125; 当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。 ​ newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针： 123func newobject(typ *_type) unsafe.Pointer &#123; return mallocgc(typ.size, typ, true)&#125; 四、总结​ 简单总结一下Go语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建切片、哈希表和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针 参考：https://blog.csdn.net/qq_32252917/article/details/102953438","categories":[{"name":"Go基础","slug":"Go基础","permalink":"https://www.yusp-spin.github.io/categories/Go%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"Sync(Go语言中的同步手段)","slug":"Sync(Go语言中的同步手段)","date":"2020-11-06T03:23:47.000Z","updated":"2020-11-06T03:53:22.025Z","comments":true,"path":"2020/11/06/Sync(Go语言中的同步手段)/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/06/Sync(Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%89%8B%E6%AE%B5)/","excerpt":"","text":"1.sync.WaitGroup​ Go语言中可以使用sync.WaitGroup来实现并发任务的同步。 ​ sync.WaitGroup内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成 sync.WaitGroup有以下几个方法： 方法名 功能 (wg * WaitGroup) Add(delta int) 计数器+delta (wg *WaitGroup) Done() 计数器-1 (wg *WaitGroup) Wait() 阻塞直到计数器变为0 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroupfunc hello() &#123; defer wg.Done() fmt.Println(&quot;hello Goroutine!&quot;)&#125;func main() &#123; wg.Add(1) go hello() fmt.Println(&quot;main gorountine done&quot;) wg.Wait()&#125; 2.sync.Once​ 确保某些操作在高并发的场景下只执行一次,sunc.Once是一个针对值执行一次场景的解决方案 ​ 整个程序，只会执行printNum()方法一次,print()方法是不会被执行的。 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var once sync.Oncefunc main() &#123; for i, v :=range make([]string, 10) &#123; once.Do(printNum) fmt.Println(&quot;count:&quot;,v,&quot;---&quot;,i) &#125; for i := 0; i &lt; 10; i++ &#123; go func() &#123; once.Do(print) fmt.Println(&quot;hello&quot;) &#125;() &#125; time.Sleep(4000)&#125;func printNum() &#123; fmt.Println(&quot;123456&quot;)&#125;func print() &#123; fmt.Println(&quot;abcdefg&quot;)&#125; 3.sync.Map​ Go语言中内置的map不是并发安全的,有些场景下就需要为map加锁来保证并发的安全性了，Go语言的sync包中提供了一个开箱即用的并发安全版map–sync.Map。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时sync.Map内置了诸如Store、Load、LoadOrStore、Delete、Range等操作方法","categories":[{"name":"并发编程（go）","slug":"并发编程（go）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88go%EF%BC%89/"}],"tags":[]},{"title":"Goroutine","slug":"Goroutine","date":"2020-11-04T04:12:47.000Z","updated":"2020-11-04T07:52:35.786Z","comments":true,"path":"2020/11/04/Goroutine/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/04/Goroutine/","excerpt":"","text":"一、Goroutine简介​ 在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？ ​ Go语言中的goroutine就是这样一种机制，goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。 ​ 在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。 二、Goroutine使用​ Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。 ​ 一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;time&quot;)func hello(s string) &#123; fmt.Println(&quot;hello&quot;, s)&#125;func main() &#123; go hello(&quot;a&quot;) go hello(&quot;b&quot;) go hello(&quot;c&quot;) time.Sleep(time.Second)&#125; 三、goroutine与线程​ OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。 goroutine调度细节——GPM模型 ​ GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。 1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。 2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。 3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的； P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。 P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。 单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。 四、Goroutine(协程)的理解​ 先了解一下进程线程协程的定义： 进程：拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程：拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度。 协程 :和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 在操作系统的OS Thread和编程语言的User Thread之间，实际上存在3种线程对应模型，也就是：1:1，1:N，M:N。 1:1：一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文切换很慢，切换效率很低。 N:1：多个（N）用户线程始终在一个内核线程上跑，context上下文切换很快，但是无法真正的利用多核。 M:N：多个goroutine在多个内核线程上跑，这个可以集齐上面两者的优势,既能快速切换上下文，也能利用多核的优势，而Go正是选择这种实现方式。 Java中的线程属于1：1，Goroutine属于M:N 简单将 goroutine归纳为协程并不合适。运行时会创建多个线程来执行并发任务,且任务单元可被调度到其他线程并行执行。这更像是多线程和协程的综合体,能最大限度提升执行效率,发挥多核处理能力。 五、总结​ 相比于线程，goroutine并不会更快，它只是增加了更多的并发性。当一goroutine被阻塞（比如等待IO）,golang的调度器会调度其它可以执行的goroutine运行。与线程相比，它有以下几个优点： 优点： 内存消耗更少：Goroutine所需要的内存通常只有2kb，而线程则需要1Mb 创建与销毁的开销更小:由于线程创建时需要向操作系统申请资源，并且在销毁时将资源归还，因此它的创建和销毁的开销比较大。相比之下，goroutine的创建和销毁是由go语言在运行时自己管理的，因此开销更低。 切换开销更小线程的调度方式是抢占式的，如果一个线程的执行时间超过了分配给它的时间片，就会被其它可执行的线程抢占;而goroutine的调度是协同式的，它不会直接地与操作系统内核打交道。 缺点： 协程调度机制无法实现公平调度：因为协程的调度是非入侵式的，系统不会为他分配资源。","categories":[{"name":"并发编程（go）","slug":"并发编程（go）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88go%EF%BC%89/"}],"tags":[{"name":"Goroutine","slug":"Goroutine","permalink":"https://www.yusp-spin.github.io/tags/Goroutine/"}]},{"title":"Gin数据库操作","slug":"Gin数据库操作","date":"2020-11-01T14:15:47.000Z","updated":"2020-11-01T14:16:03.062Z","comments":true,"path":"2020/11/01/Gin数据库操作/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/01/Gin%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"","text":"一、连接数据库​ 准备好数据库，表，同时与Gin建立连接 1234567891011//初始化数据库连接func InitDatabase() (*sql.DB, error) &#123; //将数据转换成数据库url作为返回值 url := strings.Join([]string&#123;&quot;root&quot;, &quot;:&quot;, &quot;123456&quot;, &quot;@tcp(&quot;, &quot;127.0.0.1&quot;, &quot;:&quot;, &quot;3306&quot;, &quot;)/&quot;, &quot;gomysql&quot;&#125;, &quot;&quot;) db, err := sql.Open(&quot;mysql&quot;, url) if err != nil &#123; log.Printf(&quot;open database error:%v&quot;, err) return nil, err &#125; return db, nil&#125; ​ 新建一个全局变量sql.DB方便我们后期调用，然后通过 sql.Open对数据进行连接 二、增删改​ 往数据库中增删改 12345678910111213//用于增删改 //执行增、改、删任务 func Execute(db *sql.DB, sql string, params ...interface&#123;&#125;) error &#123; stmt, _ := db.Prepare(sql) //预编译 defer stmt.Close() _, err := stmt.Exec(params...) if err != nil &#123; log.Printf(&quot;execute sql error:%v\\n&quot;, err) return err &#125; log.Println(&quot;execute sql success&quot;) return nil &#125; 三、查询123456789101112//查询数据库数据func QueryData(db *sql.DB, sql string, params ...interface&#123;&#125;) (*sql.Rows, error) &#123; stmt, _ := db.Prepare(sql) defer stmt.Close() rows, err := stmt.Query(params...) if err != nil &#123; log.Printf(&quot;query data error:%v&quot;, err) return nil, err &#125; log.Println(&quot;query data success&quot;) return rows, nil&#125; 四、总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package mainimport ( &quot;database/sql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;log&quot; &quot;strings&quot;)type Student struct &#123; id int name string age int&#125;func main() &#123; db, err := InitDatabase() defer db.Close() if err != nil &#123; log.Println(err) return &#125; //增加 insert := &quot;insert into person (name, age) values (?,?)&quot; err = Execute(db, insert, &quot;xiaoming&quot;, 23) if err != nil &#123; log.Println(&quot;insert data error : %v\\n&quot;, err) return &#125; querySql := &quot;select * from person&quot; data, err := QueryData(db,querySql) defer data.Close() if err != nil &#123; log.Printf(&quot;query data error:%v\\n&quot;, err) return &#125; s := new(Student) for data.Next() &#123; data.Scan(&amp;s.id, &amp;s.name, &amp;s.age) log.Println(*s) &#125;&#125;//初始化数据库连接func InitDatabase() (*sql.DB, error) &#123; //将数据转换成数据库url作为返回值 url := strings.Join([]string&#123;&quot;root&quot;, &quot;:&quot;, &quot;123456&quot;, &quot;@tcp(&quot;, &quot;127.0.0.1&quot;, &quot;:&quot;, &quot;3306&quot;, &quot;)/&quot;, &quot;gomysql&quot;&#125;, &quot;&quot;) db, err := sql.Open(&quot;mysql&quot;, url) if err != nil &#123; log.Printf(&quot;open database error:%v&quot;, err) return nil, err &#125; return db, nil&#125;//用于增删改 //执行增、改、删任务 func Execute(db *sql.DB, sql string, params ...interface&#123;&#125;) error &#123; stmt, _ := db.Prepare(sql) //预编译 defer stmt.Close() _, err := stmt.Exec(params...) if err != nil &#123; log.Printf(&quot;execute sql error:%v\\n&quot;, err) return err &#125; log.Println(&quot;execute sql success&quot;) return nil &#125;//查询数据库数据func QueryData(db *sql.DB, sql string, params ...interface&#123;&#125;) (*sql.Rows, error) &#123; stmt, _ := db.Prepare(sql) defer stmt.Close() rows, err := stmt.Query(params...) if err != nil &#123; log.Printf(&quot;query data error:%v&quot;, err) return nil, err &#125; log.Println(&quot;query data success&quot;) return rows, nil&#125;","categories":[{"name":"Gin框架","slug":"Gin框架","permalink":"https://www.yusp-spin.github.io/categories/Gin%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"Gin框架入门","slug":"Gin入门","date":"2020-11-01T02:12:47.000Z","updated":"2020-11-01T14:11:45.499Z","comments":true,"path":"2020/11/01/Gin入门/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/01/Gin%E5%85%A5%E9%97%A8/","excerpt":"","text":"一、Gin简介​ Gin 是使用 Go/golang 语言实现的 HTTP Web 框架。接口简洁，性能极高，框架源码仅5K 二、Gin 特性 快速：路由不使用反射，基于Radix树，内存占用少。 中间件：HTTP请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP等。这个特性和 NodeJs 的 Koa 框架很像。中间件机制也极大地提高了框架的可扩展性。 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理HTTP请求过程中发生的错误。 JSON：Gin可以解析并验证请求的JSON。这个特性对Restful API的开发尤其有用。 路由分组：例如将需要授权和不需要授权的API分组，不同版本的API分组。而且分组可嵌套，且性能不受影响。 渲染内置：原生支持JSON，XML和HTML的渲染。 1234567891011121314package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, func(c *gin.Context) &#123; c.String(http.StatusOK, &quot;hello, world&quot;) &#125;) r.Run(&quot;:8000&quot;)&#125; 首先，我们使用了gin.Default()生成了一个实例，这个实例即 WSGI 应用程序。 接下来，我们使用r.Get(&quot;/&quot;, ...)声明了一个路由，告诉 Gin 什么样的URL 能触发传入的函数，这个函数返回我们想要显示在用户浏览器中的信息。 最后用 r.Run()函数来让应用运行在本地服务器上，默认监听端口是 _8080_，可以传入参数设置端口，例如r.Run(&quot;:8000&quot;)即运行在8000端口。 三、路由（Route）​ 1. 路由方法有 GET, POST, PUT, PATCH, DELETE 和 OPTIONS，还有Any，可匹配以上任意类型的请求。 ​ 2.解析路径参数；动态的路由，如 /user/:name，通过调用不同的 url 来传入不同的 name。/user/:name/*role，* 代表可选 123456789101112131415package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() r.GET(&quot;/user/:name&quot;, func(c *gin.Context) &#123; name := c.Param(&quot;name&quot;) c.String(http.StatusOK, &quot;hello,%s&quot;, name) &#125;) r.Run(&quot;:8000&quot;)&#125; ​ 3.获取Query参数 12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)// 匹配users?name=xxxfunc main() &#123; r := gin.Default() r.GET(&quot;/user&quot;, func(c *gin.Context) &#123; name := c.Query(&quot;name&quot;) c.String(http.StatusOK, &quot;hello, %s&quot;, name) &#125;) r.Run(&quot;:8000&quot;)&#125; ​ 4.获取POST参数 1234567891011121314151617181920package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() r.POST(&quot;/form&quot;, func(c *gin.Context) &#123; username := c.PostForm(&quot;username&quot;) password := c.DefaultPostForm(&quot;password&quot;, &quot;000000&quot;) // 可设置默认值 c.JSON(http.StatusOK, gin.H&#123; &quot;username&quot;: username, &quot;password&quot;: password, &#125;) &#125;) r.Run(&quot;:8000&quot;)&#125; 四、HTML模板1234567891011121314151617package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; r := gin.Default() // 指明html加载文件目录 r.LoadHTMLGlob(&quot;./html/*&quot;) r.Handle(&quot;GET&quot;, &quot;/&quot;, func(c *gin.Context) &#123; // 返回HTML文件，响应状态码200，html文件名为index.html，模板参数为nil c.HTML(http.StatusOK, &quot;index.html&quot;, nil) &#125;) r.Run()&#125;","categories":[{"name":"Gin框架","slug":"Gin框架","permalink":"https://www.yusp-spin.github.io/categories/Gin%E6%A1%86%E6%9E%B6/"}],"tags":[]},{"title":"剑指offer 56-67","slug":"剑指offer 56-67","date":"2020-11-01T01:26:03.000Z","updated":"2020-11-01T01:44:29.171Z","comments":true,"path":"2020/11/01/剑指offer 56-67/","link":"","permalink":"https://www.yusp-spin.github.io/2020/11/01/%E5%89%91%E6%8C%87offer%2056-67/","excerpt":"","text":"56.删除链表中重复的结点​ 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910111213141516171819202122public class Solution &#123; public ListNode deleteDuplication(ListNode head) &#123; ListNode res=new ListNode(0); res.next=head; ListNode pre=res; ListNode cur=head; while(cur!=null)&#123; if(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; cur=cur.next; pre.next=cur; &#125;else&#123; pre=pre.next; cur=cur.next; &#125; &#125; return res.next; &#125;&#125; 57.二叉树的下一个结点​ 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode root) &#123; if(root==null)&#123; return root; &#125; if(root.right!=null)&#123; root=root.right; while(root.left!=null)&#123; root=root.left; &#125; return root; &#125; if(root.next!=null&amp;&amp;root.next.left==root)&#123; return root.next; &#125; while(root.next!=null&amp;&amp;root.next.right==root)&#123; root=root.next; &#125; return root.next; &#125;&#125; 58.对称的二叉树12345678910111213141516171819202122public class Solution &#123; boolean isSymmetrical(TreeNode root) &#123; if(root==null)&#123; return true; &#125; return help(root.left,root.right); &#125; private boolean help(TreeNode p,TreeNode q)&#123; if(p==null&amp;&amp;q==null)&#123; return true; &#125; if(p==null||q==null)&#123; return false; &#125; if(p.val!=q.val)&#123; return false; &#125; return help(p.left,q.right)&amp;&amp;help(p.right,q.left); &#125;&#125; 59.按之字形顺序打印二叉树​ 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res=new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null)&#123; return res; &#125; int index=0; queue.add(root); while(!queue.isEmpty())&#123; int size=queue.size(); ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; TreeNode node=queue.poll(); if(index%2==0)&#123; list.add(node.val); &#125;else&#123; list.add(0,node.val); &#125; if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; &#125; index++; res.add(new ArrayList&lt;&gt;(list)); &#125; return res; &#125; &#125; 60.把二叉树打印成多行​ 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 123456789101112131415161718192021222324252627public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; res=new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); if(root==null)&#123; return res; &#125; queue.add(root); while(!queue.isEmpty())&#123; int size=queue.size(); ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; TreeNode node=queue.poll(); list.add(node.val); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; &#125; res.add(new ArrayList&lt;&gt;(list)); &#125; return res; &#125; &#125; 61.序列化二叉树请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; String Serialize(TreeNode root) &#123; String res = &quot;&quot;; if(root==null)&#123; return &quot;#!&quot;; &#125; res+=root.val+&quot;!&quot;; res+=Serialize(root.left); res+=Serialize(root.right); return res; &#125; TreeNode Deserialize(String str) &#123; if(str == null || str.length()==0)&#123; return null; &#125; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] s= str.split(&quot;!&quot;); for(int i=0;i&lt;s.length;i++)&#123; queue.add(s[i]); &#125; return Deserialize(queue); &#125; private TreeNode Deserialize(Queue&lt;String&gt; queue)&#123; if(queue.isEmpty())&#123; return null; &#125; String s=queue.poll(); if(s.equals(&quot;#&quot;))&#123; return null; &#125; TreeNode root = new TreeNode(Integer.valueOf(s)); root.left=Deserialize(queue); root.right=Deserialize(queue); return root; &#125;&#125; 62.二叉搜索树的第k个结点​ 给定一棵二叉搜索树，请找出其中的第k小的结点。 12345678910111213141516171819202122public class Solution &#123; TreeNode KthNode(TreeNode root, int k) &#123; //中序遍历 if(root==null) &#123; return null; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty()||root!=null) &#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(--k==0)&#123; return root; &#125; root=root.right; &#125; return null; &#125;&#125; 63.数据流中的中位数​ 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 1234567891011121314151617181920212223242526272829public class Solution &#123; PriorityQueue&lt;Integer&gt; minqueue = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxqueue = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a,Integer b) &#123; return b-a; &#125; &#125;); int index=0; public void Insert(Integer num) &#123; if(index%2==0)&#123; minqueue.add(num); maxqueue.add(minqueue.poll()); &#125;else&#123; maxqueue.add(num); minqueue.add(maxqueue.poll()); &#125; index++; &#125; public Double GetMedian() &#123; if(index%2==1)&#123; return maxqueue.peek()/1.0; &#125;else&#123; return (maxqueue.peek()+minqueue.peek())/2.0; &#125; &#125;&#125; 64.滑动窗口的最大值​ 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 窗口大于数组长度的时候，返回空 123456789101112131415161718192021222324public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int len=num.length; if(num.length&lt;size||size&lt;1)&#123; return res; &#125; LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; while(!queue.isEmpty()&amp;&amp;num[queue.peekLast()]&lt;=num[i])&#123; queue.pollLast(); &#125; queue.addLast(i); if(queue.peekFirst()==i-size)&#123; queue.pollFirst(); &#125; if(i&gt;=size-1)&#123; res.add(num[queue.peekFirst()]); &#125; &#125; return res; &#125;&#125; 65.单词搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; char[][] board; boolean[][] used; int rows; int cols; char[] str; int[][] dep=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; this.rows=rows; this.cols=cols; this.board = new char[rows][cols]; this.used = new boolean[rows][cols]; this.str=str; int p=0; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; board[i][j]=matrix[p++]; &#125; &#125; for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(dfs(i,j,0))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean dfs(int i,int j,int index)&#123; if(index==str.length-1)&#123; return board[i][j]==str[index]; &#125; //if(used[i][j])&#123; // return false; // &#125; if(board[i][j]==str[index])&#123; used[i][j]=true; for(int a=0;a&lt;4;a++)&#123; int x=i+dep[a][0]; int y=j+dep[a][1]; if(x&gt;=0&amp;&amp;x&lt;rows&amp;&amp;y&gt;=0&amp;&amp;y&lt;cols&amp;&amp;!used[x][y])&#123; if(dfs(x,y,index+1))&#123; return true; &#125; &#125; &#125; used[i][j]=false; &#125; return false; &#125; 66.机器人的运动范围​ 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 12345678910111213141516171819202122232425262728293031public class Solution &#123; int threshold; int rows; int cols; boolean[][] used; public int movingCount(int threshold, int rows, int cols) &#123; this.threshold = threshold; this.rows = rows; this.cols = cols; used = new boolean[rows][cols]; return help(0,0); &#125; private int help(int i,int j) &#123; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||((isSum(i)+isSum(j))&gt;threshold)||used[i][j]) &#123; return 0; &#125; used[i][j]=true; return help(i-1,j)+help(i,j-1)+help(i+1,j)+help(i,j+1)+1; &#125; private int isSum(int i) &#123; int sum = 0; while(i!=0)&#123; sum+=(i%10); i/=10; &#125; return sum; &#125;&#125; 67.剪绳子​ 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 123456789101112131415161718public class Solution &#123; public int cutRope(int target) &#123; if (target &lt;= 3) &#123; return target - 1; &#125; int [] dp = new int[target + 1]; // dp[0] = 0; //dp[1] = 1; dp[2] = 2; dp[3] = 3; for(int i = 4; i &lt;= target; i++) &#123; // for(int j = 1; j &lt;= i / 2; j++) &#123; dp[i] = Math.max(dp[i-2]*2, dp[i-3]*3); // &#125; &#125; return dp[target]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"操作系统-进程管理-用户级线程和内核级线程的区别","slug":"操作系统-进程管理-用户级线程和内核级线程的区别","date":"2020-10-31T09:07:23.000Z","updated":"2020-10-31T09:17:08.903Z","comments":true,"path":"2020/10/31/操作系统-进程管理-用户级线程和内核级线程的区别/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、线程的分类​ 线程的实现可以分为两大类：用户级线程和内核级线程。 1.用户级线程​ 在一个纯粹的用户级线程软件中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。任何应用程序都可以通过使用线程库被设计成多线程程序。线程库是用于用户级线程管理的一个例程包，它包含用于创建和销毁线程的代码、在线程间传递消息和数据的代码、调度线程执行的代码、以及保存和恢复线程上下文的代码。在默认情况下，应用程序从单线程开始，并在该线程中开始运行。该应用程序及其线程被分配给一个由内核管理的进程。在应用程序正在运行（进程处于运行态）的任何时刻，应用程序都可以派生一个在相同进程中运行的新线程（派生线程是通过调用线程库中的派生例程完成的，通过过程调用，控制权被传递给派生例程）。线程库为新线程创建一个数据结构，然后使用某种调度算法，把控制权传递给该进程中处于就绪态的一个线程。当控制权被传递给线程库时，需要保存当前线程的上下文，然后当控制权从线程库中传递给一个线程时，将恢复哪个线程的上下文。上下文实际上包括用户寄存器的内容、程序计数器和栈指针 在前一段描述的所有活动都发生在用户空间中，并且发生在一个进程内，而内核并不知道这些活动。内核继续以进程为单位进行调度，并且给该进程指定一个执行状态。 使用用户级线程而不是内核线程有很多优点： 1、由于所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核态特权； 2、调度可以是应用程序相关的，可以做到为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序； 3、用户级线程可以在任何操作系统中运行，线程库是一组供所有应用程序共享的应用程序级别的函数。 使用用户级线程而不是内核线程有两个明显的缺点： 1、当用户级线程执行一个会引起阻塞的系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞； 2、在纯粹的用户级线程策略中，多线程应用程序不能利用多处理技术，内核一次只把一个进程分配给一个处理器，因此一次进程中只有一个线程可以执行。 2.内核级线程在一个纯粹的内核级线程软件中，有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口（API）。Windows 是这种方法的一个例子。 内核为进程及其内部的每个线程维护上下文信息。调度是由内核基于线程完成的。该方法克服了用户级线程方法的两个基本缺陷（优点：）： 首先：内核可以同时把同一个进程中的多个线程调度到多个处理器中； 再者：如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程； 另外：内核例程自身也是可以使用多线程的。 缺点：把控制从一个线程传送到同一个进程内的另一个线程时，需要到内核的状态转换 二、Windows线程​ Windows 使用两类与进程相关的对象：进程和线程。 ​ 进程是对应一个拥有内存、打开的文件等资源的用户作业或应用程序的实体。线程是顺序执行的一个科分派的工作单元，并且它是可中断的，因此，处理器可以切换到另一个线程。一个 Windows 进程必须至少包含一个执行线程，该线程可能会创建别的线程。在多处理器系统中，同一个进程的多个线程可以并行的执行。 ​ 由于不同进程中的线程可能并非执行，因而 Windows 支持进程间的并发性。此外，同一个进程中的多个线程可以分配给不同的处理器并且同时执行。一个含有多线程的进程在实现并发时，不需要使用多进程的开销。同一个进程中的线程可以通过他们的公共地址空间交换信息，并访问进程中的共享资源，不同进程中的线程可以通过在两个进程间建立的共享内存交换信息 三、Linux的进程和线程管理​ Linux 中的进程或任务由一个 task_struct 数据结构表示。 ​ 传统的 UNIX 系统支持每个执行的进程中只有一个单独的一个线程，但现代典型的 UNIX 系统支持一个进程中含有多个 内核级线程。 ** Linux 提供一种不区分进程和线程的解决方案**。用户级线程被映射到内核级进程上，组成一个用户级进程的多个用户级线程被映射到共享同一个组 ID 的多个 Linux 内核级进程上。这使得这些进程可以共享文件和内存等资源，使得同一组中的进程调度切换时不需要切换上下文。 ​ 当两个进程共享相同的虚存时，它们可以被当做是一个进程中的线程。 ​ 当 Linux 内核执行从一个进程到另一个进程的切换时，它将坚持当前进程的页目录地址是否和将被调度的进程相同。如果相同，那么它们共享同一个地址空间，所以此时上下文切换仅仅是从代码的一处跳转到代码的另一处。 ​ 虽然属于同一进程组的被克隆的进程共享同一内存空间，但它们不能共享同一个用户栈。 四、总结​ 用户级线程对操作系统是未知的，它们由一个在进程的用户空间中运行的线程库创建并管理。用户线程是非常高效的，因为从一个线程切换到另一个线程不需要进行状态切换，但是，一个进程中一次只有一个用户级线程可以执行，如果一个线程发生阻塞，整个进程都会被阻塞。 ​ 进程内包含的内核级线程是由内核维护的。由于内核认识它们，因而同一个进程中的多个线程可以再多个处理器上并行执行，一个线程的阻塞不会阻塞整个进程，但当从一个线程切换到另一个线程时就会需要进行模式切换。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.yusp-spin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"剑指offer 46-55","slug":"剑指offer 46-55","date":"2020-10-31T05:26:24.000Z","updated":"2020-10-31T05:38:17.133Z","comments":true,"path":"2020/10/31/剑指offer 46-55/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/31/%E5%89%91%E6%8C%87offer%2046-55/","excerpt":"","text":"46.孩子们的游戏(圆圈中最后剩下的数)​ 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 12345678910111213141516171819public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(m==0||n==0)&#123; return -1; &#125; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; res.add(i); &#125; int index=-1; while(res.size()&gt;1)&#123; index=(index+m)%res.size(); res.remove(index); index--; &#125; return res.get(0); &#125;&#125; 47.求1+2+3+…+n​ 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 1234567public class Solution &#123; public int Sum_Solution(int n) &#123; int sum=n; boolean flag=n&gt;0&amp;&amp;(sum+=Sum_Solution(n-1))&gt;0; return sum; &#125;&#125; 48.不用加减乘除做加法​ 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 123456789101112public class Solution &#123; public int Add(int num1,int num2) &#123; int tmp=0; while(num1!=0)&#123; tmp=(num1^num2); num1=((num1&amp;num2)&lt;&lt;1); num2=tmp; &#125; return num2; &#125;&#125; 49.把字符串转换成整数​ 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 123456789101112131415161718192021222324252627282930public class Solution &#123; public int StrToInt(String str) &#123; if(str==null||str.length()==0)&#123; return 0; &#125; boolean flag=true; int index=0; if(str.charAt(index)==&#x27;+&#x27;)&#123; index++; &#125;else if(str.charAt(index)==&#x27;-&#x27;)&#123; index++; flag=false; &#125; int sum=0; for(int i=index;i&lt;str.length();i++)&#123; if(str.charAt(i)&lt;&#x27;0&#x27;||str.charAt(i)&gt;&#x27;9&#x27;)&#123; return 0; &#125; int p = str.charAt(i)-&#x27;0&#x27;; if(flag&amp;&amp;((sum==Integer.MAX_VALUE/10&amp;&amp;p&gt;7)||sum&gt;Integer.MAX_VALUE/10))&#123; return Integer.MAX_VALUE; &#125; if(!flag&amp;&amp;((-sum==Integer.MIN_VALUE/10&amp;&amp;p&gt;8)||-sum&lt;Integer.MIN_VALUE/10))&#123; return Integer.MIN_VALUE; &#125; sum=sum*10+p; &#125; return flag?sum:-sum; &#125;&#125; 50.数组中重复的数字​ 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 1234567891011121314151617181920212223242526272829public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(length==0)&#123; return false; &#125; for(int i=0;i&lt;length;i++)&#123; while(numbers[i]!=i)&#123; if(numbers[i]==numbers[numbers[i]])&#123; duplication[0]=numbers[i]; return true; &#125;else &#123; int tmp=numbers[i]; numbers[i]=numbers[tmp]; numbers[tmp]=tmp; &#125; &#125; &#125; return false; &#125;&#125; 51.构建乘积数组​ 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…*A[i-1]A[i+1]…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];） 对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。 1234567891011121314151617181920public class Solution &#123; public int[] multiply(int[] A) &#123; int len=A.length; if(len==0)&#123; return A; &#125; int[] B=new int[len]; int tmp=1; for(int i=0;i&lt;len;i++)&#123; B[i]=tmp; tmp*=A[i]; &#125; tmp=1; for(int i=len-1;i&gt;=0;i--)&#123; B[i]*=tmp; tmp*=A[i]; &#125; return B; &#125;&#125; 52.正则表达式匹配​ 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 12345678910111213141516171819202122232425262728public class Solution &#123; Integer[][] memo; public boolean match(char[] str, char[] p) &#123; int m=str.length; int n=p.length; memo = new Integer[m+1][n+1]; return help(str,p,0,0); &#125; private boolean help(char[] c,char[] p,int i,int j)&#123; if(j==p.length)&#123; return i==c.length; &#125; if(memo[i][j]!=null)&#123; return memo[i][j]!=-1; &#125; boolean firstMatch = i&lt;c.length&amp;&amp;j&lt;p.length&amp;&amp;(c[i]==p[j]||p[j]==&#x27;.&#x27;); boolean ans; if(j+1&lt;p.length&amp;&amp;p[j+1]==&#x27;*&#x27;)&#123; ans=help(c,p,i,j+2)||(firstMatch&amp;&amp;help(c,p,i+1,j)); &#125;else&#123; ans=help(c,p,i+1,j+1)&amp;&amp;firstMatch; &#125; memo[i][j]=ans?1:-1; return ans; &#125;&#125; 53.表示数值的字符串​ 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 1234567891011121314151617181920212223242526272829public class Solution &#123; int index=0; public boolean isNumeric(char[] str) &#123; boolean flag = isPoNum(str); if(index&lt;str.length&amp;&amp;str[index]==&#x27;.&#x27;)&#123; index++; flag = isNum(str)||flag; &#125; if(index&lt;str.length&amp;&amp;(str[index]==&#x27;e&#x27;||str[index]==&#x27;E&#x27;))&#123; index++; flag = isPoNum(str)&amp;&amp;flag; &#125; return flag&amp;&amp;index==str.length; &#125; private boolean isPoNum(char[] str)&#123; if(index&lt;str.length&amp;&amp;(str[index]==&#x27;+&#x27;||str[index]==&#x27;-&#x27;)) index++; return isNum(str); &#125; private boolean isNum(char[] str)&#123; int start=index; while(index&lt;str.length&amp;&amp;(str[index]&gt;=&#x27;0&#x27;&amp;&amp;str[index]&lt;=&#x27;9&#x27;))&#123; index++; &#125; return index&gt;start; &#125;&#125; 54.字符流中第一个不重复的字符​ 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 1234567891011121314151617181920212223242526public class Solution &#123; //Insert one char from stringstream Queue&lt;Character&gt; queue=new LinkedList&lt;&gt;(); int[] map = new int[256]; public void Insert(char ch) &#123; map[ch]++; if(map[ch]==1)&#123; queue.add(ch); &#125; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; char c = &#x27;#&#x27;; while(!queue.isEmpty())&#123; c=queue.peek(); if(map[c]==1)&#123; return c; &#125;else&#123; queue.poll(); &#125; &#125; return &#x27;#&#x27;; &#125;&#125; 55.链表中环的入口结点给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 1234567891011121314151617181920212223242526public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode head) &#123; ListNode p=head; ListNode q=head; while(q!=null&amp;&amp;q.next!=null)&#123; p=p.next; q=q.next.next; if(p==q)&#123; break; &#125; &#125; if(q==null||q.next==null)&#123; return null; &#125; p=head; while(p!=q)&#123; p=p.next; q=q.next; &#125; return p; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 36-45","slug":"剑指offer 36-45","date":"2020-10-30T10:26:24.000Z","updated":"2020-10-30T10:42:34.407Z","comments":true,"path":"2020/10/30/剑指offer 36-45/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/30/%E5%89%91%E6%8C%87offer%2036-45/","excerpt":"","text":"36.两个链表的第一个公共节点​ 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 1234567891011public class Solution &#123; public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) &#123; ListNode p=head1; ListNode q=head2; while(p!=q)&#123; p=p==null?head2:p.next; q=q==null?head1:q.next; &#125; return p; &#125;&#125; 37.数字在排序数组中出现的次数​ 统计一个数字在升序数组中出现的次数。 12345678910111213141516171819202122232425public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; int len=array.length; if(len==0)&#123; return 0; &#125; int l=help(array,k); int r=help(array,k+1); return r&gt;l?r-l:0; &#125; private int help(int[] arr,int k)&#123; int l=0; int r=arr.length-1; while(l&lt;=r)&#123; int mid=(l+r)/2; if(arr[mid]&lt;k)&#123; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; return l; &#125;&#125; 38.二叉树的深度​ 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 123456789public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; return Math.max(TreeDepth(root.left),TreeDepth(root.right))+1; &#125;&#125; 39.平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。 1234567891011121314151617181920212223public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; if(root==null)&#123; return true; &#125; return help(root)!=-1; &#125; private int help(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; int left=help(root.left); if(left==-1)&#123; return -1; &#125; int right=help(root.right); if(right==-1)&#123; return -1; &#125; return Math.abs(left-right)&lt;=1?Math.max(left,right)+1:-1; &#125;&#125; 40.数组中只出现一次的数字​ 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 123456789101112131415161718192021public class Solution &#123; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int val=0; for(int num:array)&#123; val^=num; &#125; int index=1; while((index&amp;val)==0)&#123; index&lt;&lt;=1; &#125; num1[0]=0; num2[0]=0; for(int num:array)&#123; if((num&amp;index)==0)&#123; num1[0]^=num; &#125;else&#123; num2[0]^=num; &#125; &#125; &#125;&#125; 41.和为S的连续正数序列​ 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 1234567891011121314151617181920212223public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt;res=new ArrayList&lt;&gt;(); int l=1; int r=2; while(r&lt;sum)&#123; int tmp=(l+r)*(r-l+1)/2; if(tmp==sum)&#123; ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); for(int i=l;i&lt;=r;i++)&#123; list.add(i); &#125; res.add(new ArrayList&lt;&gt;(list)); l++; &#125;else if(tmp&lt;sum)&#123; r++; &#125;else&#123; l++; &#125; &#125; return res; &#125;&#125; 42.和为S的两个数字​ 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 123456789101112131415161718192021222324public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); int len=array.length; if(len==0)&#123; return res; &#125; int l=0; int r=len-1; while(l&lt;r)&#123; int tmp=array[l]+array[r]; if(tmp==sum)&#123; res.add(array[l]); res.add(array[r]); return res; &#125;else if(tmp&gt;sum)&#123; r--; &#125;else&#123; l++; &#125; &#125; return res; &#125;&#125; 43.左旋转字符串​ 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 123456789public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(n&gt;str.length())&#123; return &quot;&quot;; &#125; return str.substring(n,str.length())+str.substring(0,n); &#125;&#125; 44.翻转单词顺序列​ 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 123456789101112131415161718192021public class Solution &#123; public String ReverseSentence(String str) &#123; if(str.trim().length()==0)&#123; return str; &#125; String[] c=str.split(&quot;\\\\s+&quot;); for(int i=0;i&lt;c.length/2;i++)&#123; String tmp=c[i]; c[i]=c[c.length-1-i]; c[c.length-1-i]=tmp; &#125; StringBuffer sb=new StringBuffer(); for(int i=0;i&lt;c.length;i++)&#123; sb.append(c[i]); if(i!=c.length-1)&#123; sb.append(&quot; &quot;); &#125; &#125; return sb.toString(); &#125;&#125; 45.扑克牌顺子​ LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 12345678910111213141516171819202122232425public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; int len=numbers.length; if(len&lt;5)&#123; return false; &#125; int count=0; int p=0; Arrays.sort(numbers); for(int i=0;i&lt;len;i++)&#123; if(numbers[i]==0)&#123; count++; &#125;else&#123; if(i&lt;len-1&amp;&amp;numbers[i]==numbers[i+1])&#123; return false; &#125; if(i&lt;len-1)&#123; p+=(numbers[i+1]-numbers[i]-1); &#125; &#125; &#125; return count&gt;=p; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"最近——纠结与困扰","slug":"最近困扰","date":"2020-10-30T05:24:50.000Z","updated":"2020-11-11T14:14:21.448Z","comments":true,"path":"2020/10/30/最近困扰/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/30/%E6%9C%80%E8%BF%91%E5%9B%B0%E6%89%B0/","excerpt":"","text":"没想到我也会经历纠结的一天，意向的offer想在腾讯字节快手猿辅导中选一个，但是我是一个典型的纠结人格，纠结了平台和福利待遇和技术栈和业务方向和wlb，纠结纠结…… 最后应该会去快手吧 反省自己，感觉自己从材料专业转出来，眼界真的太狭隘了，整整一两个月没有学习新知识，天天在关心offer发了没有，总包多少这些事，不去提升技术而是在关心一些蝇头小利这是我的一个很大的缺点 给自己立个flag，11月份深入学习netty和操作系统，明年毕业前刷到800道leecode，目前是450道，博客文章更多更有含量，元旦前写完大文章，元旦后开始写小文章，准备毕业","categories":[{"name":"life","slug":"life","permalink":"https://www.yusp-spin.github.io/categories/life/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"进程管理","slug":"操作系统-进程管理","date":"2020-10-29T14:33:47.000Z","updated":"2020-10-29T05:58:11.143Z","comments":true,"path":"2020/10/29/操作系统-进程管理/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"一、进程的引入和概念 程序的顺序执行最简单的程序设计方法是顺序的方法，这种方法有以下特点： ①. 程序在运行时独占资源，叫做封闭性；②. 程序执行时，只要初始条件相同，无论程序是连续执行还是断续执行，结果不变，叫做可再现性 程序的并行执行 进程的概念①. 进程定义 进程又叫做任务，是程序的一次执行过程，是程序在一个数据集合上顺序执行发生的活动，是系统资源分配的单位 ②. 进程和程序的联系和区别 进程是程序的一次执行过程，具有动态性，而程序是一种可以长期保存的软件资源；进程是系统进行资源分配和资源调度的一个独立单位，句有独立性，程序不是；进程可以与其他进程并行； 二、进程的描述 进程控制块为了描述进程的运行变化情况，操作系统为每个进程定义了一个数据结构叫做进程控制块（PCB），也叫进程描述符，是进程的唯一标志，包含了进程的描述信息和管理控制信息。 PCB包含的信息： ①. 进程标志数 ②. 进程的状态以及调度和存储器管理信息 ③. 进程使用的资源信息，包括分配给进程的IO设备、正在执行的IO请求信息 ④、CPU现场保护区 ⑤、记账信息，包括CPU时间量等 ⑥、进程之间的家族关系 ⑦、进程的链接指针 进程的状态创建态、终止态、就绪态、运行态、阻塞等待态 ①. 创建态，进程刚刚被创建 ②. 终止态， 进程不再受处理及调度管理，可能是正常完成或者已经中断 ③. 就绪态，已经获得了除cpu之外的所有资源，等待系统分配CPU ④. 运行态，正在CPU执行的进程 ⑤. 阻塞等待态，等待某些资源 进程的组织进程控制块是系统对进程统一管理的依据，为了便于系统管理，通常对系统中的进程采用两种组织方式 ①. 线性表 把所有进程的PCB组成一个数组，系统通过数组下标访问每一个PCB。系统通过数组下标访问每一个PCB，优点是简单，节省存储空间，缺点是系统开销大 ②. 链接表 将同一状态下的进程链接成一个队列，系统会设置一个指针指向当前运行进程的PCB。 三、进程的控制​ 所谓进程控制是指系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间转换的一系列有效管理。 ​ 用于控制进程的原语如下： 创建原语创建原语的功能：创建一个进程主要是为进程创建一个PCB，扫描系统的PCB的集合表，找到一个空闲的PCB，并获得PCB的内部名称，作为进程的标识。若程序和数据不在主存，也应为其分配主存，并调入主存，把调用者的参数填入PCB中，将状态置为就绪，插入队列中。 撤销原语撤销，归还资源 阻塞原语处于运行态的进程中断CPU，将其运行现场保存在其PCB的CPU现场保护区；状态置为阻塞态，插入相应等待队列 唤醒原语 挂前期原语 激活原语 四、处理机的调度 处理机调度的级别作业调度、进程调度、交换调度 作业调度是让作业有资格获得CPU，作业的运行需要通过进程调度实现，处理机的交换调度是为了使得资源分配更加合理 进程调度的方式非抢先方式 抢先方式 处理机调度算法先来先到服务、最短作业优先、最短剩余时间优先、优先级调度，时间片轮转算法、多级反馈队列算法 五、 线程 进程和线程的区别 线程分类用户级线程、核心线程、两级结合 ​","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.yusp-spin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程","slug":"进程","permalink":"https://www.yusp-spin.github.io/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"学习过程中一些网站的收藏","slug":"一些好网站","date":"2020-10-28T07:22:47.000Z","updated":"2020-10-28T05:38:04.166Z","comments":true,"path":"2020/10/28/一些好网站/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/28/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%BD%91%E7%AB%99/","excerpt":"","text":"Bookmarks Bookmarks Bookmarks bar 算法 (3条未读私信) 全部动态_牛客网 力扣 (LeetCode) 官网 - 全球极客挚爱的技术成长平台 https://mp.weixin.qq.com/mp/homepage?__biz=MzI4Njc4MzMwMw==&amp;hid=1&amp;sn=58bf8e995138b26984c05fd51f198196 openJDK Red Hat Developer | Red Hat OpenJDK Getting Started study 黑马Struts框架_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili JavaWeb学习——struts1框架篇_长亭古道的博客-CSDN博客 廿廿不忘 东南大学“贰零贰零 不忘初心”跨年演唱会 Feign - HTTP接口调用- 单独使用 - 实战 Java多线程编程-（9）-ThreadLocal造成OOM内存溢出案例演示与原理分析_徐刘根的博客-CSDN博客 这才是 Thread Local 的正确原理与适用场景 根本没有内存泄漏 | 技术世界 | java,thread local,java 8,CAS,多线程,并发,技术世界,郭俊 Jason ThreadLocal 定义，以及是否可能引起的内存泄露(threadlocalMap的Key是弱引用，用线程池有可能泄露) - aspirant - 博客园 GitHub - CyC2018/CS-Notes: 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++ 全部文章详细分类与整理（算法+数据结构+计算机基础） GitHub - ZhongFuCheng3y/3y: 从Java基础、JavaWeb基础到常用的框架再到面试题都有完整的教程，几乎涵盖了Java后端必备的知识点 Snailclimb/JavaGuide: 【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。 史上最全的数据库面试题，不看绝对后悔_资源分享_牛客网 NIO学习教程_Java_Andrew_Yuan的博客-CSDN博客 spring boot 启动原理详细解析 - jstarseven - 博客园 Zookeeper系列六：服务器角色、序列化与通信协议、数据存储、zookeeper总结 - 小不点啊 - 博客园 SpringBoot系列一：SpringBoot的产生 - 小不点啊 - 博客园 Zookeeper系列二：分布式架构详解、分布式技术详解、分布式事务 - 小不点啊 - 博客园 Zookeeper 总结 - 知乎 ZooKeeper常见面试题_大数据_Alyson_han的博客-CSDN博客 一致性算法（Paxos、Raft、ZAB） - mathor 分布式理论系列（二）一致性算法：2PC 到 3PC 到 Paxos 到 Raft 到 Zab CodeBear - 博客园 JVM垃圾收集器总结 - 方块人 - 博客园 Backend-Interview-Guide/一文帮你理清面试知识点.md at master · CyC2018/Backend-Interview-Guide lvs+nginx负载均衡 - 木子木泗 - 博客园 20+互联网公司（阿里头条美团滴滴等）面经（Java方向）_笔经面经_牛客网 面试刷题10-7_网络_wwxy1995的博客-CSDN博客 Java 线程模型 - jqc - 博客园 透彻的掌握 Spring 中@transactional 的使用 - 茄子_2008 - 博客园 Java面试知识点总结-数据库_牛客博客 总结了一些大佬的面试题目，欢迎大佬补充_笔经面经_牛客网 网易云信技术分享：IM中的万人群聊技术方案实践总结 - helloJackJiang - 博客园 经典面试智力题200+题和解答_C/C++_Kayven@数据-CSDN博客 【Java面试必备】最近5年133个Java面试问题列表_笔经面经_牛客网 sql锁的类型介绍：悲观锁，乐观锁，行锁，表锁，页锁，共享锁，排他锁，意向锁 - 强迫疒 - 博客园 100道MySQL常见面试题总结_索引 动态规划套路详解 - 零钱兑换 - 力扣（LeetCode） 深入浅出Mybatis系列（一）---Mybatis入门 - 南轲梦 - 博客园 深入浅出Mybatis系列（三）---配置详解之properties与environments（mybatis源码篇） - 南轲梦 - 博客园 Spring常见面试题总结（超详细回答）_Java_a745233700的博客-CSDN博客 内核级线程（KLT）和用户级线程（ULT）_运维_vinter_he-CSDN博客 【SpringBoot商城秒杀系统项目总结25】 项目的亮点和难点及问题解决（源码地址）_Java_Brad_PiTt7的博客-CSDN博客 大白话布隆过滤器 - CodeBear - 博客园 分布式系统面试题：分布式事务解决方案？_数据库_weixin_34211761的博客-CSDN博客 【JAVA秒会技术之秒杀面试官】JavaEE常见面试题（三）_Java_qq296398300的博客-CSDN博客 数据结构中各种树 - xin Tech - 博客园 吊打面试官：dubbo高频面试题_技术交流_牛客网 题库 - AcWing 2. 01背包问题 - AcWing题库 01背包的理解，二维数组化一维数组的理解（附hdu2602 Bone Collector）_Python_酱油拌面-CSDN博客 深入理解Spring cloud源码篇之Eureka源码_Java_lgq2626的博客-CSDN博客 Redis 的通信协议 RESP | 江伟的笔记 Linux内核解析:进程间通信：管道 - 笨拙的菜鸟 - 博客园 Java中实现序列化的两种方式 Serializable 接口和 Externalizable接口 - guodaxia - 博客园 Collection 类关系图 | Java 全栈知识体系 【Java春秋招】常见MySQL面试题_牛客博客 大数据处理 - 分治/hash/排序 | Java 全栈知识体系 Java中“附近的人”实现方案讨论及代码实现 - larscheng - 博客园 消息中间件系列二：RabbitMQ入门（基本概念、RabbitMQ的安装和运行） - 小不点啊 - 博客园 Zookeeper面试题 - lanqiu5ge - 博客园 Zookeeper面试题 - lanqiu5ge - 博客园 doocs/advanced-java: 😮 互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识，后端同学必看，前端同学也可学习 Linux awk统计日志中出现过的IP(或出现次数最多的N个IP)_运维_jirryzhang的博客-CSDN博客 写文章-CSDN博客 个人资料-个人中心-CSDN Java-JVM-安全点SafePoint_Java_baichoufei90的专栏-CSDN博客 一次完整的HTTP事务是怎样一个过程？-雷纳科斯的博客-51CTO博客 【HR面】那些年，HR面试的套路们_笔经面经_牛客网 影响HTTP性能的常见因素 - 昀溪 - 博客园 字节跳动，算法题汇总。_笔经面经_牛客网 redis主从复制下哨兵模式---选举原理 - 秋雨声 - 博客园 源码 2020年最新spring源码教程（大厂面试必问系列）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili B站最全Spring全家桶教程——深入源码底层（2019最新）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 鲁班学院资料连接 - 腾讯文档 Java工程师 高并发与多线程网络编程 （完）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili Java工程师 高并发与多线程网络编程 （完）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili Spring Boot 2.x 启动全过程源码分析 - 简书 【Java | 源码分析】为了2020年面试阿里巴巴，死磕了这几个知识！_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili Java工程师 高并发与多线程网络编程 （完）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili JUC源码解析文章目录_业精于勤荒于嬉 行成于思毁于随-CSDN博客 深入分析AQS实现原理 - 并发编程 - SegmentFault 思否 详解并发中的AQS Java并发编程笔记之 CountDownLatch闭锁的源码分析 - 妮蔻 - 博客园 死磕 java同步系列之Semaphore源码解析 - 彤哥读源码 - 博客园 HashMap源码解析_业精于勤荒于嬉 行成于思毁于随-CSDN博客 HashMap源码解读 - 沦为旧友 - 博客园 死磕 java集合之HashMap源码分析 - 彤哥读源码 - 博客园 深入分析java线程池的实现原理 - 简书 JDK1.7 HashMap 导致循环链表 - 陈树义 - 博客园 举一个例子说说为什么要封装_鸟哥的专栏-CSDN博客 Java对象为啥要实现Serializable接口？ 阿里资深Java架构师一堂课带你吃透动态代理，解密SpringAOP源码_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 浅谈操作系统 IO 模式_技术交流_牛客网 一篇文章搞懂红黑树的原理及实现 - 简书 Java6及以上版本对synchronized的优化 - 蜗牛大师 - 博客园 https://mp.weixin.qq.com/s/XEpdRGiPiwvm1ieTMfBsUA 死磕 java同步系列之volatile解析 - 彤哥读源码 - 博客园 springboot配置线程池-高并发场景_Arvinzr的博客-CSDN博客 spring线程池ThreadPoolTaskExecutor与阻塞队列BlockingQueue - 大招无限 - 博客园 Java 面试问题_w3cschool quartz系列教材 （一）- Quartz 教程 Quartz官方文档_w3cschool java中内存泄露8种情况的总结_ratel的博客-CSDN博客 常见的内存泄漏原因及解决方法 - 简书 数据结构和算法（六）：前缀、中缀、后缀表达式 - 知乎 KMP 算法详解 - 知乎 辰砂tj - 博客园 tomcat类加载器为什么要破坏双亲委派机制？ - 牧云文仔 - 博客园 为什么分布式要有分布式锁 - 朱正刚 - 博客园 深入理解单例模式：静态内部类单例原理_Java_mnb65482的博客-CSDN博客 Spring中涉及的设计模式总结_Java_iCoding91-CSDN博客 Java泛型类型擦除以及类型擦除带来的问题 - 蜗牛大师 - 博客园 【Java 并发笔记】volatile 相关整理 - 简书 JDK和CGLIB动态代理原理区别 - 一步之 - 博客园 CGLib动态代理的实现_Java_huhahuha_的博客-CSDN博客 一步步分析为什么B+树适合作为索引的结构 以及索引原理 (阿里面试) - aspirant - 博客园 对B+树，B树，红黑树的理解 - myseries - 博客园 Spring Boot 构建电商基础秒杀项目 (二) 使用 Spring MVC 方式获取用户信息 - VictorBu - 博客园 MySQL中的悲观锁 - 简书 MySQL事务隔离级别和MVCC Mybatis 延迟加载 - 一条路上的咸鱼 - 博客园 (1条未读通知) java的封神之路_技术交流_牛客网 mybatis一级缓存二级缓存 - 寻找风口的猪 - 博客园 mybatis-spring – MyBatis-Spring | 事务 spring-boot-seckill: 从0到1构建分布式秒杀系统，脱离案例讲架构都是耍流氓 src/main/java/com/itstyle/seckill/web/SeckillDistributedController.java · 小柒2012/spring-boot-seckill - 码云 - 开源中国 使用Redis实现分布式Session（完整实现）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili AOP是怎么实现的，有几种方式 - stanljj - 博客园 集群,分布式，微服务概念和区别理解 - 李凡金牛 - 博客园 分布式事务的四种解决方案 - 无敌是多么寂寞啊 - 博客园 图解Nginx限流配置 - 程序员赵鑫 - 博客园 分布式事务中常见的三种解决方案 - Bluemiaomiao - 博客园 分布式事务的解决方案详解_Java_Ghostbamboo的博客-CSDN博客 SpringBoot集成redisson(单机,集群,哨兵) - 简书 【搞定算法】常见算法题分类总览_网络_震哥聊校招-CSDN博客 快速排序---(面试碰到过好几次)_网络_nrsc-CSDN博客 手写一个HashMap_悟空的博客的博客-CSDN博客 hash()方法 - 江-南 - 博客园 (1条未读通知) 操作系统基础知识梳理_资源分享_牛客网 JVM性能调优 - sweet6 - 博客园 Java程序内存分析：使用mat工具分析内存占用 - 孤剑 - 博客园 JVisualVM简介与内存泄漏实战分析_Java_Bingo-CSDN博客 Shiro框架 （原理分析与简单实现） - yinliangyun - 博客园 (1条未读通知) Shiro安全框架简单入门_资源分享_牛客网 (1条未读通知) 如何保证数据库与缓存双写时的数据一致性_技术交流_牛客网 (1条未读通知) Redis cluster集群模式的原理_技术交流_牛客网 阿里Java面经大全（整合版）_牛客博客 理解Nginx工作原理 - 简书 面试智力题集锦 (1条未读通知) 【盘点】面试中常常看见的智力题_笔经面经_牛客网 消息中间件面试题：消息丢失怎么办？ - 简书 尚硅谷_SpringCloud（全）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili Spring Cloud的面试题_Java_oldshaui的博客-CSDN博客 Springboot学习笔记（一）-线程池的简化及使用 - 舒山 - 博客园 rabbitmq常见面试题_大数据_jeffry_ding的博客-CSDN博客 RabbitMQ实战-消息确认机制之消息的正确消费_大数据_不忘初心 砥砺前行-CSDN博客 线程池之ThreadPoolExecutor线程池源码分析笔记 - 妮蔻 - 博客园 线程池ThreadPoolExecutor参数设置_Java_周宏亮G的日志-CSDN博客 树形结构的数据库表设计_数据库_spin的博客-CSDN博客 HashMap面试总结 - feifei97 - 博客园 跨专业渣硕春招逆袭之旅(附面经)_技术交流_牛客网 框架 揭秘 Spring AOP 失效的罪因！ 剑指Spring源码（二） - CodeBear - 博客园 剑指Spring源码（一） - CodeBear - 博客园 spring源码解析之AOP原理 - 恶魔、天使与码农 - 博客园 深入浅出Mybatis系列（十）---SQL执行流程分析（源码篇） - 南轲梦 - 博客园 就业 个人中心 | Tencent 校园招聘 百度招聘 我的应聘|阿里巴巴校园招聘 网易校园招聘 快手校园招聘 Coremail System QQMail - Inbox","categories":[],"tags":[]},{"title":"剑指offer 26-35","slug":"剑指offer 26-35","date":"2020-10-27T14:59:02.000Z","updated":"2020-10-27T15:30:21.797Z","comments":true,"path":"2020/10/27/剑指offer 26-35/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/27/%E5%89%91%E6%8C%87offer%2026-35/","excerpt":"","text":"26. 二叉搜索树与双向链表​ 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 123456789101112131415161718192021222324252627282930public class Solution &#123; TreeNode head; TreeNode cur; public TreeNode Convert(TreeNode root) &#123; if(root==null)&#123; return root; &#125; inorder(root); return head; &#125; private void inorder(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); while(root!=null||!stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root=stack.pop(); if(head==null)&#123; head=root; cur=root; &#125;else&#123; cur.right=root; root.left=cur; cur=cur.right; &#125; root=root.right; &#125; &#125;&#125; 27.字符串的排列​ 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; TreeSet&lt;String&gt; res=new TreeSet&lt;&gt;(); ArrayList&lt;Character&gt; list=new ArrayList&lt;&gt;(); boolean[] used; public ArrayList&lt;String&gt; Permutation(String str) &#123; if(str==null||str.length()==0)&#123; return new ArrayList&lt;&gt;(); &#125; used=new boolean[str.length()]; help(str.toCharArray(),0); return new ArrayList&lt;&gt;(res); &#125; private void help(char[] c,int index)&#123; if(index==c.length)&#123; StringBuffer sb=new StringBuffer(); for(char cs:list)&#123; sb.append(cs); &#125; res.add(sb.toString()); return; &#125; for(int i=0;i&lt;c.length;i++)&#123; if(used[i])&#123; continue; &#125; used[i]=true; list.add(c[i]); help(c,index+1); list.remove(list.size()-1); used[i]=false; &#125; &#125;&#125; ​ 28.数组中出现次数超过一半的数字 ​ 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 1234567891011121314151617181920212223242526272829303132public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; int count=0; int candidate=0; int len=array.length; if(len==0)&#123; return 0; &#125; for(int i=0;i&lt;len;i++)&#123; if(count==0)&#123; candidate=array[i]; count++; &#125;else&#123; if(candidate==array[i])&#123; count++; &#125;else&#123; count--; &#125; &#125; &#125; if(count==0)&#123; return 0; &#125; count=0; for(int n:array)&#123; if(candidate==n)&#123; count++; &#125; &#125; return count&gt;len/2?candidate:0; &#125;&#125; 29.最小的k个数​ 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 1234567891011121314151617181920212223public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; if(input.length&lt;k||k&lt;=0)&#123; return new ArrayList&lt;&gt;(); &#125; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a,Integer b)&#123; return b-a; &#125; &#125;); for(int i=0;i&lt;input.length;i++)&#123; if(i&lt;k)&#123; queue.add(input[i]); &#125;else&#123; if(queue.peek()&gt;input[i])&#123; queue.poll(); queue.add(input[i]); &#125; &#125; &#125; return new ArrayList&lt;&gt;(queue); &#125;&#125; 30.连续子数组的最大和​ 返回最大连续子序列的和 1234567891011public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int max=array[0]; int res=array[0]; for(int i=1;i&lt;array.length;i++)&#123; max=Math.max(max+array[i],array[i]); res=Math.max(res,max); &#125; return res; &#125;&#125; 31.整数中1出现的次数​ 求出113的整数中1出现的次数,并算出1001300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 1234567891011public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count=0; for(int m=1;m&lt;=n;m*=10)&#123; int a=n/m; int b=n%m; count+=(a+8)/10*m+(a%10==1?b+1:0); &#125; return count; &#125;&#125; 32.把数组排成最小的数​ 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314151617181920212223public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; int len=numbers.length; if(len==0)&#123; return &quot;&quot;; &#125; Integer[] arr=new Integer[len]; int index=0; for(int n:numbers)&#123; arr[index++]=n; &#125; Arrays.sort(arr,new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a,Integer b)&#123; return (a+&quot;&quot;+b).compareTo(b+&quot;&quot;+a); &#125; &#125;); StringBuffer sb=new StringBuffer(); for(Integer a:arr)&#123; sb.append(a); &#125; return sb.toString(); &#125;&#125; 33.丑数​ 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516171819202122232425public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;1)&#123; return 0; &#125; int[] dp=new int[index]; dp[0]=1; int a=0; int b=0; int c=0; for(int i=1;i&lt;index;i++)&#123; dp[i]=Math.min(dp[a]*2,Math.min(dp[b]*3,dp[c]*5)); if(dp[i]==dp[a]*2)&#123; a++; &#125; if(dp[i]==dp[b]*3)&#123; b++; &#125; if(dp[i]==dp[c]*5)&#123; c++; &#125; &#125; return dp[index-1]; &#125;&#125; 34.第一次只出现一次的字符​ 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） 12345678910111213141516public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; int[] arr=new int[128]; char[] cs=str.toCharArray(); for(char p:cs)&#123; arr[p]++; &#125; for(int i=0;i&lt;cs.length;i++)&#123; if(arr[cs[i]]==1)&#123; return i; &#125; &#125; return -1; &#125;&#125; 35.数组中的逆序对​ 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 123456789101112131415161718192021222324252627282930313233343536373839404142public class Solution &#123; public int InversePairs(int [] array) &#123; if(array == null || array.length == 0) &#123; return 0; &#125; return mergesort(array, 0, array.length - 1); &#125; private int mergesort(int[] arr, int l, int r) &#123; if(l &gt;= r) &#123; return 0; &#125; int mid = l + (r - l) / 2; return (mergesort(arr, l, mid) + mergesort(arr, mid + 1, r) + merge(arr, l, mid, r)) % 1000000007;&#125; private int merge(int[] arr, int l, int mid ,int r) &#123; int[] help = new int[r - l + 1]; int p = l; int q = mid + 1; int index = 0; int sum = 0; while(p &lt;= mid &amp;&amp; q &lt;= r) &#123; if(arr[p] &lt;= arr [q]) &#123; help[index++] = arr[p++]; &#125;else if( arr[p] &gt; arr[q])&#123; sum = (sum + mid - p + 1) % 1000000007; help[index++] = arr[q++]; &#125; &#125; while(p &lt;= mid) &#123; help[index++] = arr[p++]; &#125; while( q &lt;= r) &#123; help[index++] = arr[q++]; &#125; for(int i = l; i &lt;= r; i++) &#123; arr[i] = help[i - l]; &#125; return sum % 1000000007; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 16-25","slug":"剑指offer 16-25","date":"2020-10-20T13:54:02.000Z","updated":"2020-10-20T14:20:35.456Z","comments":true,"path":"2020/10/20/剑指offer 16-25/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/20/%E5%89%91%E6%8C%87offer%2016-25/","excerpt":"","text":"16. 合并两个有序链表​ 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324public class Solution &#123; public ListNode Merge(ListNode list1, ListNode list2) &#123; ListNode head = new ListNode(0); ListNode p = head; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt;= list2.val) &#123; p.next = list1; list1 = list1.next; &#125; else &#123; p.next = list2; list2 = list2.next; &#125; p = p.next; &#125; if (list1 != null) &#123; p.next = list1; &#125; if (list2 != null) &#123; p.next = list2; &#125; return head.next; &#125;&#125; 17.树的子结构​ 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 1234567891011121314151617181920public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) &#123; return false; &#125; return help(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean help(TreeNode root1, TreeNode root2) &#123; if (root2 == null) &#123; return true; &#125; if (root1 == null) &#123; return false; &#125; if (root1.val != root2.val) &#123; return false; &#125; return help(root1.left, root2.left) &amp;&amp; help(root1.right, root2.right); &#125;&#125; 18.二叉树的镜像​ 操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112public class Solution &#123; public void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; Mirror(root.left); Mirror(root.right); &#125;&#125; 19.顺时针打印矩阵​ 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); int m=matrix.length; if(m==0)&#123; return res; &#125; int n=matrix[0].length; int left=0; int right=n-1; int up=0; int down=m-1; while(true)&#123; for(int i=left;i&lt;=right;i++)&#123; res.add(matrix[up][i]); &#125; if(++up&gt;down)&#123; break; &#125; for(int i=up;i&lt;=down;i++)&#123; res.add(matrix[i][right]); &#125; if(--right&lt;left)&#123; break; &#125; for(int i=right;i&gt;=left;i--)&#123; res.add(matrix[down][i]); &#125; if(--down&lt;up)&#123; break; &#125; for(int i=down;i&gt;=up;i--)&#123; res.add(matrix[i][left]); &#125; if(++left&gt;right)&#123; break; &#125; &#125; return res; &#125;&#125; 20.包含min函数的栈​ 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); Stack&lt;Integer&gt; min=new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); if(min.isEmpty()||min.peek()&gt;=node)&#123; min.push(node); &#125;else&#123; min.push(min.peek()); &#125; &#125; public void pop() &#123; if(stack.isEmpty()&amp;&amp;min.isEmpty())&#123; return; &#125; stack.pop(); min.pop(); &#125; public int top() &#123; if(stack.isEmpty()&amp;&amp;min.isEmpty())&#123; return -1; &#125; return stack.peek(); &#125; public int min() &#123; if(stack.isEmpty()&amp;&amp;min.isEmpty())&#123; return -1; &#125; return min.peek(); &#125;&#125; 21.栈的压入、弹出序列​ 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 1234567891011121314public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; int index=0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;pushA.length;i++)&#123; stack.push(pushA[i]); while(!stack.isEmpty()&amp;&amp;(stack.peek()==popA[index]))&#123; stack.pop(); index++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 22.从上往下打印二叉树​ 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 123456789101112131415161718192021222324public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root==null)&#123; return res; &#125; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size=queue.size(); for(int i=0;i&lt;size;i++)&#123; TreeNode node=queue.poll(); res.add(node.val); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; &#125; &#125; return res; &#125;&#125; 23.二叉搜索树的后序遍历序列​ 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; int len=sequence.length; if(len==0)&#123; return false; &#125; return help(sequence,0,len-1); &#125; private boolean help(int[] sequence,int l,int r)&#123; if(l&gt;=r)&#123; return true; &#125; int key=sequence[r]; int i=l; for(;i&lt;r;i++)&#123; if(sequence[i]&gt;key)&#123; break; &#125; &#125; for(int j=i;j&lt;r;j++)&#123; if(sequence[j]&lt;key)&#123; return false; &#125; &#125; return help(sequence,l,i-1)&amp;&amp;help(sequence,i+1,r); &#125;&#125; 24.二叉树中和为某一值的路径​ 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 1234567891011121314151617181920212223242526public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root==null)&#123; return res; &#125; help(root,target); return res; &#125; private void help(TreeNode root,int target)&#123; if(root==null)&#123; return; &#125; target-=root.val; list.add(root.val); if(root.left==null&amp;&amp;root.right==null&amp;&amp;target==0)&#123; res.add(new ArrayList&lt;&gt;(list)); &#125; help(root.left,target); help(root.right,target); list.remove(list.size()-1); &#125;&#125; 25.复杂链表的复制​ 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 1234567891011121314151617181920212223public class Solution &#123; public RandomListNode Clone(RandomListNode head) &#123; if(head==null)&#123; return head; &#125; Map&lt;RandomListNode,RandomListNode&gt;map=new HashMap&lt;&gt;(); RandomListNode cur=head; while(cur!=null)&#123; map.put(cur,new RandomListNode(cur.label)); cur=cur.next; &#125; cur=head; while(cur!=null)&#123; RandomListNode p=map.get(cur); p.next=map.get(cur.next); p.random=map.get(cur.random); cur=cur.next; &#125; return map.get(head); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"零拷贝（Zero-copy）学习","slug":"零拷贝","date":"2020-10-16T02:02:27.000Z","updated":"2020-10-16T03:48:05.949Z","comments":true,"path":"2020/10/16/零拷贝/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/16/%E9%9B%B6%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"概念零拷贝（Zero-copy）是一种高效的数据传输机制，是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域 传统IO传输方法12345678public static void main(String[] args) throws IOException &#123; File file = new File(&quot;test.txt&quot;); RandomAccessFile accessFile = new RandomAccessFile(file, &quot;rw&quot;); byte[] arr = new byte[(int) file.length()]; accessFile.read(arr); Socket socket = new ServerSocket(6666).accept(); socket.getOutputStream().write(arr);&#125; 从操作系统层面来看这一次传输操作 1.JVM向OS发出read()系统调用，触发上下文切换，从用户态切换到内核态。 2.从外部存储（如硬盘）读取文件内容，通过直接内存访问（DMA）存入内核地址空间的缓冲区。 3.将数据从内核缓冲区拷贝到用户空间缓冲区，read()系统调用返回，并从内核态切换回用户态。 4.JVM向OS发出write()系统调用，触发上下文切换，从用户态切换到内核态。 5.将数据从用户缓冲区拷贝到内核中与目的地Socket关联的缓冲区。 6.数据最终经由Socket通过DMA传送到硬件（如网卡）缓冲区，write()系统调用返回，并从内核态切换回用户态。 上面总共是经过了4次上下文切换（严格来讲是模式切换），并且数据也被来回拷贝了4次 第2、3次拷贝（也就是从内核空间到用户空间的来回复制）是没有意义的，数据应该可以直接从内核缓冲区直接送入Socket缓冲区。零拷贝机制就实现了这一点。不过零拷贝需要由操作系统直接支持，不同OS有不同的实现方法 零拷贝下面的零拷贝机制下的时序图。 零拷贝消除了从内核空间到用户空间的来回复制，因此“zero-copy”这个词实际上是站在内核的角度来说的，并不是完全不会发生任何拷贝。 在Java NIO包中提供了零拷贝机制对应的API，即FileChannel.transferTo()方法，可将拷贝次数变为3次，上下文切换次数减少到2次。 Scatter/Gather的优化​ 从“Read buffer”到“Socket buffer”，在一般的Block DMA方式中，源物理地址和目标物理地址都得是连续的，所以一次只能传输物理上连续的一块数据，每传输一个块发起一次中断，直到传输完成，所以必须要在两个缓冲区之间拷贝数据。 而Scatter/Gather DMA方式则不同，会预先维护一个物理上不连续的块描述符的链表，描述符中包含有数据的起始地址和长度。传输时只需要遍历链表，按序传输数据，全部完成后发起一次中断即可，效率比Block DMA要高。也就是说，硬件可以通过Scatter/Gather DMA直接从内核缓冲区中取得全部数据，不需要再从内核缓冲区向Socket缓冲区拷贝数据。 对内存映射（mmap）的支持以上机制，如果想在传输时修改数据本身，就无能为力了，不过，很多操作系统也提供了内存映射机制，对应的系统调用为mmap()/munmap()。通过它可以将文件数据映射到内核地址空间，直接进行操作 但是呢，这样会造成4次上下文切换，另外，它需要在快表（TLB）中始终维护着所有数据对应的地址空间，直到刷写完成，因此处理缺页的overhead也会更大。在使用该机制时，需要权衡效率。 NIO框架中提供了MappedByteBuffer用来支持mmap。它与常用的DirectByteBuffer一样，都是在堆外内存分配空间。相对地，HeapByteBuffer在堆内内存分配空间。 参考：https://www.jianshu.com/p/193cae9cbf07","categories":[{"name":"IO","slug":"IO","permalink":"https://www.yusp-spin.github.io/categories/IO/"}],"tags":[{"name":"零拷贝","slug":"零拷贝","permalink":"https://www.yusp-spin.github.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"}]},{"title":"浅谈操作系统概论","slug":"操作系统-概论","date":"2020-10-12T14:33:47.000Z","updated":"2020-10-12T15:48:20.595Z","comments":true,"path":"2020/10/12/操作系统-概论/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/","excerpt":"","text":"计算机系统的组成硬件：中央处理器（cpu），存储器（外存，内存），输入输出设备 操作系统 程序 2.操作系统的发展​ 顺序处理 ​ 简单批处理系统: 使用一个监控程序按顺序自动将作业装入内存处理 ​ 多道批处理系统：主存同时存放多个用户作业，提高效率 ​ 分时系统：将cpu的单位时间划分成若干个时间片，轮流分配给各联机用户使用 ​ 实时系统：不以作业为处理对象，而是数据或信息作为处理对象，对外部时间作出及时响应和处理 ​ 嵌入式系统 3. 操作系统的组成​ 进程管理，内存管理，设备管理，文件管理 4.用户于操作系统的接口（主要讲系统调用）系统调用：通过系统调用命令，向操作系统提出资源请求或获得系统的一些功能服务 CPU的两种操作方式：用户态，内核态 系统调用命令：进程控制，文件管理，设备管理，权限管理 系统调用流程：1.通过陷入使系统切换到核心态（需要硬件支持）；2.将程序计数器和处理机的当前状态存入任务的堆栈中；3.将系统调用号存入核心堆栈中；4.执行汇编代码保持通用寄存器的内容；5. 执行相应操作系统例程来完成系统调用；6.返回到用户方式 5.操作系统的运行方式","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.yusp-spin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"剑指offer 6-15","slug":"剑指offer 6-15","date":"2020-10-05T01:48:47.000Z","updated":"2020-10-06T07:54:14.513Z","comments":true,"path":"2020/10/05/剑指offer 6-15/","link":"","permalink":"https://www.yusp-spin.github.io/2020/10/05/%E5%89%91%E6%8C%87offer%206-15/","excerpt":"","text":"6. 矩形覆盖​ 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2n的大矩形，总共有多少种方法？ 12345678public class Solution &#123; public int RectCover(int target) &#123; if(target &lt;= 2) &#123; return target; &#125; return RectCover(target - 1) + RectCover(target - 2); &#125;&#125; 7. 斐波那契数列​ 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39 12345678public class Solution &#123; public int Fibonacci(int n) &#123; if (n &lt;= 1) &#123; return n; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2); &#125;&#125; 8. 跳台阶​ 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果） 12345678public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt;= 2) &#123; return target; &#125; return JumpFloor(target - 1) + JumpFloor(target - 2); &#125;&#125; 9.变态跳台阶​ 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 12345678public class Solution &#123; public int JumpFloorII(int target) &#123; if (target &lt;= 2)&#123; return target; &#125; return 2 * JumpFloorII(target - 1); &#125;&#125; 10.矩形覆盖​ 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2n的大矩形，总共有多少种方法？ 123456789public class Solution &#123; public int RectCover(int target) &#123; if (target &lt;= 2) &#123; return target; &#125; return RectCover(target - 1) + RectCover(target - 2); &#125;&#125; 11.二进制中1的个数输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n != 0) &#123; n = n &amp;(n-1); count++; &#125; return count; &#125;&#125; 12.数值的整数次方​ 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0 123456789101112131415161718192021222324252627public class Solution &#123; public double Power(double base, int exponent) &#123; if(base == 0.0) &#123; return 0.0; &#125; if(exponent == 0) &#123; return 1.0; &#125; if(exponent &lt; 0) &#123; exponent = -exponent; base = 1 / base; &#125; return fastpow(base, exponent); &#125; private double fastpow(double base,int exponent) &#123; if(exponent == 0)&#123; return 1; &#125; double half = fastpow(base, exponent / 2); if (exponent % 2 == 0) &#123; return half * half; &#125; else &#123; return half * half * base; &#125; &#125;&#125; 13.调整数组顺序使奇数位于偶数前面​ 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 1234567891011121314151617181920212223242526public class Solution &#123; public void reOrderArray(int [] array) &#123; int i = 0; while (i &lt; array.length) &#123; while (array[i] % 2 == 1) &#123; i++; if (i == array.length) &#123; return; &#125; &#125; int j = i; while (array[j] % 2 == 0) &#123; j++; if(j == array.length) &#123; return; &#125; &#125; int tmp = array[j]; while (j &gt; i) &#123; array[j] = array[j - 1]; j--; &#125; array[i] = tmp; &#125; &#125;&#125; 14.链表中倒数第k个结点​ 输入一个链表，输出该链表中倒数第k个结点。 1234567891011121314151617181920212223public class Solution &#123; public ListNode FindKthToTail(ListNode head, int k) &#123; ListNode p = head; ListNode q = head; while(q != null) &#123; q = q.next; if (--k == 0) &#123; break; &#125; &#125; if (q == null &amp;&amp; k == 0) &#123; return head; &#125; if (q == null) &#123; return null; &#125; while (q != null) &#123; p = p.next; q = q.next; &#125; return p; &#125;&#125; 15.反转链表​ 输入一个链表，反转链表后，输出新链表的表头。 1234567891011121314151617public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode pre = null; ListNode cur = head; ListNode next = null; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offer 1-5","slug":"剑指offer 1-5","date":"2020-09-27T01:48:47.000Z","updated":"2020-09-27T02:00:49.602Z","comments":true,"path":"2020/09/27/剑指offer 1-5/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/27/%E5%89%91%E6%8C%87offer%201-5/","excerpt":"","text":"1. 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int m = array.length; if(m == 0) &#123; return false; &#125; int n = array[0].length; int i = m - 1; int j = 0; while (i &gt;= 0 &amp;&amp; j &lt; n) &#123; if (array[i][j] == target) &#123; return true; &#125; else if(array[i][j] &gt; target) &#123; i--; &#125; else &#123; j++; &#125; &#125; return false; &#125;&#125; 2. 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234567891011121314public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String s = str.toString(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == &#x27; &#x27;) &#123; sb.append(&quot;%20&quot;); &#125; else &#123; sb.append(s.charAt(i)); &#125; &#125; return sb.toString(); &#125;&#125; 3. 从尾到头打印链表输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 12345678910public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode head) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (head != null) &#123; res.add(0,head.val); head = head.next; &#125; return res; &#125;&#125; 4. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 123456789101112131415161718192021222324public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if (pre.length == 0) &#123; return null; &#125; int key = pre[0]; if (pre.length != in.length) &#123; return null; &#125; int len = pre.length; int i = 0; for (; i &lt; len; i++) &#123; if (in[i] == key) &#123; break; &#125; &#125; TreeNode root = new TreeNode(key); root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i)); root.right=reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, len), Arrays.copyOfRange(in, i + 1, len)); return root; &#125;&#125; 5. 用两个栈实现队列用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1234567891011121314151617public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(!stack2.isEmpty())&#123; return stack2.pop(); &#125;else&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"手撕KMP","slug":"手撕KMp","date":"2020-09-19T03:22:47.000Z","updated":"2020-09-19T03:34:10.384Z","comments":true,"path":"2020/09/19/手撕KMp/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/19/%E6%89%8B%E6%92%95KMp/","excerpt":"","text":"之前看到一个好的KMP理解方法，记录一下 参考：https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485979&amp;idx=2&amp;sn=56d4d0dd11951c29c9e6f94803d92e03&amp;scene=21#wechat_redirect 123456789101112131415161718192021222324252627282930313233343536373839404142package com.CSDN;public class KMP &#123; private int[][] dp; private String pat; public KMP(String pat)&#123; this.pat=pat; int m=pat.length(); dp=new int[m][256]; dp[0][pat.charAt(0)]=1; int X=0; for(int j=1;j&lt;m;j++)&#123; for(int c=0;c&lt;256;c++)&#123; if(pat.charAt(j)==c)&#123; dp[j][c]=j+1; &#125;else&#123; dp[j][c]=dp[X][c]; &#125; &#125; X=dp[X][j]; &#125; &#125; public int serach(String txt)&#123; int m=pat.length(); int n=txt.length(); int j=0; for (int i = 0; i &lt; n; i++) &#123; j=dp[j][txt.charAt(i)]; if(j==m)&#123; return i-m+1; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; KMP K=new KMP(&quot;bcja&quot;); System.out.println(K.serach(&quot;abcjdsbcjahfksd&quot;)); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://www.yusp-spin.github.io/tags/KMP/"}]},{"title":"动态规划-数组","slug":"动态规划-数组","date":"2020-09-15T14:33:47.000Z","updated":"2020-09-16T12:37:22.804Z","comments":true,"path":"2020/09/15/动态规划-数组/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%95%B0%E7%BB%84/","excerpt":"","text":"两个数组最长公共子数组 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int[] arr1=&#123;3,4576,768,3,35,68,7,43&#125;; int[] arr2=&#123;54,67,3,3,768,3,35,564&#125;;//768,3,35 int m=arr1.length; int n=arr2.length; int[][] dp=new int[m][n]; int start=0; int end=0; int maxlen=0; for (int i = 1; i &lt;=m ; i++) &#123; for (int j = 1; j &lt;=n ; j++) &#123; if(arr1[i-1]==arr2[j-1])&#123; dp[i][j]=dp[i-1][j-1]+1; if(dp[i][j]&gt;maxlen)&#123; maxlen=dp[i][j]; start=i-maxlen; end=i; &#125; &#125; &#125; &#125; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); for(int i=start;i&lt;end;i++)&#123; res.add(arr1[i]); &#125; System.out.println(res); &#125; 两个数组最长公共子序列长度 1234567891011121314151617public static void main(String[] args) &#123; int[] arr1=&#123;1,9999,777777,3,8888888,5,7,9,33333333&#125;; int[] arr2=&#123;12,334,456,87,1,3,5,456,7,9,435,12&#125;; int m=arr1.length; int n=arr2.length; int[][] dp=new int[m+1][n+1]; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(arr1[i-1]==arr2[j-1])&#123; dp[i][j]=dp[i-1][j-1]+1; &#125;else&#123; dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; System.out.println(dp[m][n]);&#125; 连续子数组之和最大值123456789101112public int maxSubArray(int[] nums) &#123; if(nums.length==0)&#123; return 0; &#125; int sum=0; int res=Integer.MIN_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; sum=Math.max(sum+nums[i],nums[i]); res=Math.max(res,sum); &#125; return res;&#125; 连续子数组乘积最大值 12345678910111213141516171819 int m=nums.length; if(m==0)&#123; return 0; &#125; int max=nums[0]; int min=nums[0]; int res=nums[0]; for(int i=1;i&lt;m;i++)&#123; if(nums[i]&lt;0)&#123; int tmp=max; max=min; min=tmp; &#125; max=Math.max(max*nums[i],nums[i]); min=Math.min(min*nums[i],nums[i]); res=Math.max(res,max); &#125; return res;&#125; 最长上升子序列1234567891011121314151617181920public int lengthOfLIS(int[] nums) &#123; int n=nums.length; if(n==0)&#123; return 0; &#125; int[] dp=new int[n]; Arrays.fill(dp,1); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(nums[i]&gt;nums[j])&#123; dp[i]=Math.max(dp[i],dp[j]+1); &#125; &#125; &#125; int res=0; for(int i=0;i&lt;n;i++)&#123; res=Math.max(res,dp[i]); &#125; return res;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.yusp-spin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"手撕线程池","slug":"手撕线程池","date":"2020-09-15T14:22:47.000Z","updated":"2020-09-15T14:09:31.727Z","comments":true,"path":"2020/09/15/手撕线程池/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/15/%E6%89%8B%E6%92%95%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"线程池是一个很重要的知识点，有时候面试官还会让手撕，所以这里就写了一个简单的线程池 参考：https://blog.csdn.net/hongtaolong/article/details/87808009 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.CSDN;import java.util.HashSet;import java.util.Set;import java.util.concurrent.ArrayBlockingQueue;public class MyThreadPoool &#123; private static final int WORK_NUM=100; private static final int THREAD_NUM=5; private int worknum; private int threadnum; private final Set&lt;WorkThread&gt; threadset; private final ArrayBlockingQueue&lt;Runnable&gt; workqueue; public MyThreadPoool()&#123; this(WORK_NUM,THREAD_NUM); &#125; public MyThreadPoool(int worknum,int threadnum)&#123; this.worknum=worknum; this.threadnum=threadnum; threadset=new HashSet&lt;&gt;(); workqueue=new ArrayBlockingQueue&lt;Runnable&gt;(worknum); for (int i = 0; i &lt; threadnum; i++) &#123; WorkThread w=new WorkThread(&quot;thead&quot;+i); w.start(); workqueue.add(w); &#125; &#125; public void excute(Runnable r)&#123; try&#123; workqueue.add(r); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void shutdown()&#123; System.out.println(&quot;the ThreadPool is ready to shutdown&quot;); if(threadset==null||threadset.isEmpty())&#123; return; &#125; for(WorkThread w:threadset)&#123; w.stopthread(); w=null; &#125; threadset.clear(); &#125; public class WorkThread extends Thread&#123; public WorkThread(String name)&#123; setName(name); &#125; public void run()&#123; while(!interrupted())&#123; try&#123; Runnable runnable=workqueue.take(); if(runnable!=null)&#123; System.out.println(getName()+&quot;ready execute:&quot;+runnable.toString()); runnable.run(); &#125; runnable=null; &#125;catch (Exception e)&#123; interrupt(); e.printStackTrace(); &#125; &#125; &#125; public void stopthread()&#123; interrupt(); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"看看ThreadLocal是什么，ThreadLocalRandom呢？","slug":"看看ThreadLocal是什么，ThreadLocalRandom呢？","date":"2020-09-15T07:22:47.000Z","updated":"2020-11-04T05:31:10.141Z","comments":true,"path":"2020/09/15/看看ThreadLocal是什么，ThreadLocalRandom呢？/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/15/%E7%9C%8B%E7%9C%8BThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8CThreadLocalRandom%E5%91%A2%EF%BC%9F/","excerpt":"","text":"这两个知识点比较类似，恰巧在面试中也被频繁问起，所以对他两做一个简单的介绍 一、ThreadLocal：​ 指的是线程私有的变量，通过set，get，remove等方法进行操作，对应的底层操作其实是ThreadLocalMap​ 1.ThreadLocalMap存的是什么ThreadLocal里的键值对，key是threadlocal的弱引用，value是我们存放的值 2.ThreadLocalMap的key为什么是弱引用key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障，set，get remove后面都会调用expungeStateEntry方法，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。 3.ThreadLocalMap是怎么解决哈希冲突的开放寻址法 4 ThreadLocalMap为什么不定义在Thread里面，而是定义在ThreadLocal里面？因为是线程私有的变量，所以看似定义在Thread里面更加符合逻辑，但是ThreadLocalMap不是必需品，我们并不需要一创建Thread就有ThreadLocalMap，为了减少成本，所以定义在ThreadLocal 二、ThreadLocalRandomRandom计算随机数需要两步，根据老seed计算出新的seed；根据新的seed计算出随机数多线程如果同时获得同样的老seed就会产生同样的随机数，Random采用了CAS来保证只有一个线程获取seed，但是这样自旋会消耗很多性能，ThreadLocalRandom是相当于每个线程维护一个seed变量，不用竞争了在ThreadLocalRandom中并没有存放具体的种子，具体的种子存放在具体的调用线程的threadLocalRandomSeed变量中。和ThreadLocal类似，当线程调用ThreadLocalRandom中的current()方法时，ThreadLocalRandom负责初始化调用线程的threadLocalRandomSeed变量，也就是初始化种子。当调用ThreadLocalRandom的nextInt()方法时，实际是获取当前线程的threadLocalRandomSeed变量作为当前种子来计算新种子，然后将新种子更新到当前线程的threadLocalRandomSeed变量，然后根据这个新种子计算随机数。多个线程通过current获得的ThreadLocalRandom实例，其实获取的是同一个实例instance","categories":[{"name":"并发编程（java）","slug":"并发编程（java）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88java%EF%BC%89/"}],"tags":[{"name":"线程封闭","slug":"线程封闭","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"}]},{"title":"动态规划-字符串","slug":"动态规划-字符串","date":"2020-09-14T13:33:47.000Z","updated":"2020-09-14T13:37:52.234Z","comments":true,"path":"2020/09/14/动态规划-字符串/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"两字符串的最长公共字符串 1234567891011121314151617181920212223public static void main(String[] args) &#123; String str1=&quot;ABC12345E98765432kjask&quot;; String str2=&quot;p1234e598765432ahnxvm&quot;; int m=str1.length(); int n=str2.length(); int start=0; int end=0; int maxlen=0; int[][] dp=new int[m+1][n+1];//str1的i到str2的j的最长公共字符串 for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(str1.charAt(i-1)==str2.charAt(j-1))&#123; dp[i][j]=dp[i-1][j-1]+1; if(dp[i][j]&gt;maxlen)&#123; maxlen=dp[i][j]; start=i-maxlen; end=i; &#125; &#125; &#125; &#125; System.out.println(str1.substring(start,end));&#125; 两字符串的最长公共序列长度 123456789101112131415161718public static void main(String[] args) &#123; //最长公共子序列长度 String str1=&quot;abc98759847j374s34897o38i&quot;; String str2=&quot;bc&amp;&amp;&amp;&amp;&amp;&amp;&amp;4&amp;&amp;&amp;&amp;&amp;o3****8))&quot;; int m=str1.length(); int n=str2.length(); int[][] dp=new int[m+1][n+1]; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(str1.charAt(i-1)==str2.charAt(j-1))&#123; dp[i][j]=dp[i-1][j-1]+1; &#125;else&#123; dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]); &#125; &#125; &#125; System.out.println(dp[m][n]);&#125; 两字符串的删除操作（就是两字符串的公共序列变形） 123456789101112131415161718public static void main(String[] args) &#123; //最长公共子序列长度 String str1=&quot;set&quot;; String str2=&quot;eat&quot;; int m=str1.length(); int n=str2.length(); int[][] dp=new int[m+1][n+1]; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(str1.charAt(i-1)==str2.charAt(j-1))&#123; dp[i][j]=dp[i-1][j-1]+1; &#125;else&#123; dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]); &#125; &#125; &#125; System.out.println(m+n-2*dp[m][n]);&#125; 编辑距离 123456789101112131415161718192021public int minDistance(String word1, String word2) &#123; int m=word1.length(); int n=word2.length(); int[][] dp=new int[m+1][n+1]; for(int i=1;i&lt;=m;i++)&#123; dp[i][0]=dp[i-1][0]+1; &#125; for(int i=1;i&lt;=n;i++)&#123; dp[0][i]=dp[0][i-1]+1; &#125; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(word1.charAt(i-1)==word2.charAt(j-1))&#123; dp[i][j]=dp[i-1][j-1]; &#125;else&#123; dp[i][j]=Math.min(dp[i][j-1],Math.min(dp[i-1][j],dp[i-1][j-1]))+1; &#125; &#125; &#125; return dp[m][n];&#125; 阿里笔试题 123456789101112131415161718192021222324/** * 求多个字符串能构成的有序的最长长度（题目描述不准确） * 比如abc efg zzz efghi * 答案应该是abcefghizzz 长度是11 */ public static int music(String[] s)&#123; Arrays.sort(s); int count = s[0].length(); int dp[] = new int[s.length]; //dp数组为包含当前字符串的最大长度 dp[0] = s[0].length(); for (int i = 1; i &lt; s.length; i++) &#123; int j = s[i].length(); char x = s[i].charAt(0); for (int k = 0; k &lt; i; k++) &#123; char y = s[k].charAt(s[k].length() - 1); if(x &gt;= y)&#123; //判断是否可以连接 j = Math.max(dp[k] + s[i].length(), j); //寻找可以连接的最大长度 &#125; &#125; dp[i] = j; count = Math.max(count,j); &#125; return count; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.yusp-spin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Unsafe函数六道面试题","slug":"Unsafe函数六道面试题","date":"2020-09-14T13:22:47.000Z","updated":"2020-11-04T05:31:19.510Z","comments":true,"path":"2020/09/14/Unsafe函数六道面试题/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/Unsafe%E5%87%BD%E6%95%B0%E5%85%AD%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"Unsafe是什么？ Java 无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM 还是开了一个后门，JDK 中有一个类 Unsafe，底层是使用C/C++写的，它提供了硬件级别的原子操作。Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。 UnSafe的功能主要有：（1）实例化一个类；（2）修改私有字段的值；（3）抛出checked异常；（4）使用堆外内存；（5）CAS操作；（6）阻塞/唤醒线程；（7）内存屏障 Unsafe为什么是不安全的？ 因为官方不推荐使用,因为不安全,例如你使用unsafe创建一个超级大的数组,但是这个数组jvm是不管理的,只能你自己操作,容易oom,也不利于资源的回收. Unsafe的实例怎么获取？ a. 在jdk8和之前如果获得其单例对象是会抛出异常的，只能通过反射获取，在jdk9及以后，可以通过getUnsafe静态方法获取 b. 我们知道 unsafe是提供给java核心内库使用的，那么我们如何获取Unsafe的实例呢？当然是反射！ c. 代码： Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); f.setAccessible(true); Unsafe unsafe = (Unsafe) f.get(null); 讲一讲Unsafe中的CAS操作？ a. JUC中用到了大量的CAS，他们的底层其实都是采用Unsafe的CAS操作， b. CAS（比较与交换，Compare and swap）是一种有名的无锁算法,因为不需要加锁，性能比加锁搞。CAS是一个CPU指令。CAS还是一个乐观锁技术 c. CAS存在的问题： i. 经典的ABA问题，危害有（以栈举例），解决方案：版本号控制，有的数据结构在高位用邮戳标记；不重复使用节点引用，而是构建新的节点， ii. CAS常常搭配自旋一起使用，如果自选长时间不成功，循环时间长 开销大 iii. 只能保持一个共享变量的安全操作 Unsafe的阻塞/唤醒操作？ a. LockSupport类中的park与unpark方法对unsafe中的park与unpark方法做了封装，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。 实例化类的六种方式？ a. 通过构造方法new一个对象 b. 通过Class实例一个类 c. 通过发射实例化一个雷 d. 通过克隆 e. 通过反序列化 f. 通过Unsafe实例化一个类","categories":[{"name":"并发编程（java）","slug":"并发编程（java）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88java%EF%BC%89/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://www.yusp-spin.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"背包问题","slug":"背包问题","date":"2020-09-14T07:22:47.000Z","updated":"2020-09-14T07:24:40.652Z","comments":true,"path":"2020/09/14/背包问题/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"今天来个简单的背包问题大汇总 1. 01背包​ 01背包顾名思义就是对一种物品只有选或者不选两种选择​ 对于背包体积为W，物品数量是N，每个物品的体积是w[i]，每个物品的价值是price[i]的选择，求用这个背包装下的物品价值最大​ dp[i][j]表示数量为i体积为j的时候选出的最大价值​ 方程：dp[i][j]=Math.max(dp[i-1][j],dp[i][j-w[i]]+prices[i]) 123456789101112131415161718public static void main(String[] args) &#123; int N=4;//物品数量 int W=5;//体积 int[] w=&#123;1,2,3,4&#125;;//每个物品体积 int[] prices=&#123;2,4,4,5&#125;;//每个物品价值 int[][] dp=new int[N+1][W+1]; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;= W ; j++) &#123; //在j比w[i-1]小的时候，选不了物品，所以只能dp[i][j]=dp[i-1][j]; if(j&gt;=w[i-1])&#123; dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-w[i-1]]+prices[i-1]); &#125;else&#123; dp[i][j]=dp[i-1][j]; &#125; &#125; &#125; System.out.println(dp[N][W]);&#125; 优化：上面的装态方程只与i-1有关，因此可将二维状态方程压缩成一维状态方程方程：dp[j]=Math.max(dp[j],dp[j-w[i]]+prices[i])但是这里按照j从小打到进行计算的话，背包会被重复计算（那就是后面的完全背包问题了），所以要从大到小进行计算 123456789101112131415public static void main(String[] args) &#123; int N=4;//物品数量 int W=5;//体积 int[] w=&#123;1,2,3,4&#125;;//每个物品体积 int[] prices=&#123;2,4,4,5&#125;;//每个物品价值 int[] dp=new int[W+1]; for(int i=1;i&lt;=N;i++)&#123; for(int j=W;j&gt;=1;j--)&#123; if(j&gt;=w[i-1])&#123; dp[j]=Math.max(dp[j],dp[j-w[i-1]]+prices[i-1]); &#125; &#125; &#125; System.out.println(dp[W]);&#125; 之前一直不理解为什么j从小到大就会重复，这里引用一个例子https://blog.csdn.net/qq_33279781/article/details/52073519 假设一个物品GG价值1000，体积为2，那么假设我们按【0…..v】这个顺序遍历，那么在j=2时，dp[2] = max(dp[2], dp[0]+1000)，那么dp[2] = 1000，当j=4时，dp[4]=max(dp[4], dp[2]+1000)， dp[4] = 2000，这时我们再思考一下，GG将被放进背包两次 2. 完全背包完全背包指的就是物品的次数可以被无数次选取，非常好理解，就是之前的01背包的基础上，每个背包被重复选取，也就是我们的j从小到大的一个过程，每个背包被重复选取，求出最大值 12345678910111213public static void main(String[] args) &#123; int N=4;//物品数量 int W=5;//体积 int[] w=&#123;1,2,3,4&#125;;//每个物品体积 int[] prices=&#123;2,4,4,5&#125;;//每个物品价值 int[] dp=new int[W+1]; for(int i=1;i&lt;=N;i++)&#123; for(int j=w[i-1];j&lt;=W;j++)&#123; dp[j]=Math.max(dp[j],dp[j-w[i-1]]+prices[i-1]); &#125; &#125; System.out.println(dp[W]);&#125; 3.多重背包最简单的多重背包指的是背包能够被选取给定次数，同样的道理，在j从小到大的时候背包被无数次选取，选取次数不可控制，在01背包的基础上，j从大到小排列，每个背包只会被选取一次，在这个基础上，对每个j再加一重循环，使其被选取k次，就完成了多重背包 123456789101112131415161718public static void main(String[] args) &#123; int N=4;//物品数量 int W=5;//体积 int[] w=&#123;1,2,3,4&#125;;//每个物品体积 int[] prices=&#123;2,4,4,5&#125;;//每个物品价值 int[] nums=&#123;3,1,3,2&#125;; int[] dp=new int[W+1]; for(int i=1;i&lt;=N;i++)&#123; for(int j=W;j&gt;=1;j--)&#123; for (int k = 0; k &lt;=nums[i-1]; k++) &#123; if(j&gt;=k*w[i-1])&#123; dp[j]=Math.max(dp[j],dp[j-k*w[i-1]]+k*prices[i-1]); &#125; &#125; &#125; &#125; System.out.println(dp[W]);&#125; 参考：www.acwing.com 练习：leecode 322,416,518","categories":[{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"背包","slug":"背包","permalink":"https://www.yusp-spin.github.io/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"腾讯面经","slug":"腾讯面经","date":"2020-09-14T07:22:47.000Z","updated":"2020-09-15T05:53:50.561Z","comments":true,"path":"2020/09/14/腾讯面经/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/%E8%85%BE%E8%AE%AF%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"腾讯（天美）一面： 学什么专业的 学了多久代码 对linux了解吗？如何查看进程的指令 ps 什么是僵尸进程 什么是孤儿进程 linux下常用的信号，（比如ctrl+c） linux系统调用函数 进程间通信方式 共享内存是什么 new一块100m的对象占用物理内存吗 操作系统除了堆，栈还包括哪些段呢？ 代码段 数据段 操作系统一个栈一般多大 tcp与udp的区别 流量控制解决什么问题？采用什么算法 拥塞控制解决什么问题，采用什么算法 关闭连接的四次挥手 Time wait状态，为什么要2msl? 为什么time wait可以消除本次连接产生的报文？（因为2msl，msl最长报文的生命周期） 写过socket吗? 常用排序算法 讲讲快排原理，特点 红黑树了解吗？ 红黑树比平衡二叉树的优点在哪里，为什么？ 红黑树比AVL好在哪里 数据库常用的索引是什么？ 数据库如何实现回滚到一天前？ 数据库的备份怎么实现的？ 什么是冷备份什么是热备份 为什么是B+树，有什么优点 B+树非叶子节点存放了什么？ B+树如何利用磁盘预读特性？（因为B+树存了key，key接近） mysql读的很慢的原因怎么查询（慢查询日志和expalin） hash算法了解吗？用到哪里？ 二分查找有什么特点？对数组有什么要求呢？ 在哪刷题，刷了多少题？ 为什么要做秒杀项目？ 什么叫乐观锁，什么叫悲观锁？你的mysql怎么实现？ 什么时候是表锁，什么时候是行锁？ 分布式锁主要用在什么地方？你的分布式锁是怎么实现的？ redis锁怎么实现？ 加锁失败会怎么样？（会重复加锁）？ 为什么不用乐观锁，而是用redis？ 分布式锁如何实现按序获取锁？ zookeeper怎么实现加锁，讲讲他的触发机制？ 消息队列用来干什么的？ 死信队列是什么？ 秒杀项目如何保证HA？ redis为什么性能更高？ redis其他的数据结构一般可以用于啥功能？你用过啥？ zset为什么可以做排行榜，底层是什么？ 那你讲讲跳表？ 回到秒杀，nginx如何高可用？ 采用的什么负载均衡算法？ JAVA和C++的区别？ ​​ 二面： 填的上海，接受深圳吗？ 老家哪里？ C++了解多少？ 实习三个月让你看两本五百页的书可以完成吗 单向链表的环 二叉树两个节点的最近公共父节点（递归） 不用递归怎么做（迭代） 不用上面两种方法怎么做 TCP三次握手状态 如果UDP模拟TCP的拥塞控制过程，怎么做（我就说实现那四个算法） 拥塞避免是什么算法？ Linux操作系统查看进程的cpu？ 关系型数据库的索引和原理 王者荣耀的背包设计（前提：背包用数组实现） 微信在群里发一条消息如何广播出去？怎么实现的？用的UDP还是TCP？ 当前有收到其他offer吗？ ​​","categories":[{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"阿里面经","slug":"阿里面经","date":"2020-09-14T07:22:47.000Z","updated":"2020-09-15T14:03:01.023Z","comments":true,"path":"2020/09/14/阿里面经/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F/","excerpt":"","text":"阿里一面： 自我介绍 IOC的流程 熟悉啥数据库 设计一个树形结构的组织 写过注解没 秒杀项目的架构 项目中遇到的最大难题 类加载流程 什么时候触发full GC 空间分配担保失败 hashmap的底层 堆和栈的区别 Callable和Runable的区别 抽象类和接口的区别 反射的原理 二面： 自我介绍 讲讲秒杀项目的逻辑和架构？ 悲观锁性能不高为什么还要用分布式锁（单纯为了对比） 什么时候是行锁，什么时候是表锁？ redis和zk做分布式锁的对比 秒杀项目需要改进的地方 nginx的原理（多进程单线程多路复用） redis的原理（内存，通信，单线程，多路复用，持久化，一致性哈希） zookeeper的通信原理（想了一会，RPC） 你的xfyj项目做得都是啥内容？ 标志位更新为什么要分布式锁？ 成员变量i，用sychronized包括的i++线程安全吗（多次提示） 如何保证i++安全 讲讲volatile的作用和原理 讲讲JUC包下的内容（计数器，循环栅栏，信号量） 讲讲ArrayBlockingQueue 讲讲JVM内存结构 讲讲一个对象在内存中的变化过程,什么时候从堆到其他区域（我说创建对象实例在堆内存，做操作在栈里面，不懂~~~~~） 讲讲垃圾回收算法 数据库的隔离级别 如何保证缓存一致性 最近在看什么书籍 高考多少分 数学多少分 三面： 自我介绍 xf项目做的啥 这个项目干啥的 **项目做的啥 程序员社交平台项目做的啥 秒杀项目做的啥 讲讲平衡树 代码测评： 判断回文字符串 最长回文字符串 快排","categories":[{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"转行之路","slug":"转行之路","date":"2020-09-14T05:24:50.000Z","updated":"2020-10-30T03:10:45.008Z","comments":true,"path":"2020/09/14/转行之路/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/14/%E8%BD%AC%E8%A1%8C%E4%B9%8B%E8%B7%AF/","excerpt":"","text":"背景介绍本人本科东南大学金属材料专业，硕士在中国科学技术大学材料物理专业，学了六年材料，从我本科舍友转行，到我硕士师兄转行，到认识越来越多转行的人，终于，也带动了我这颗躁动的心，明白了什么叫及时止损，最后一年醒悟，自学计算机，怒转码农。我选择的是java开发入手学习，一是因为java的生态比较成熟，学习资料也比较多；二是因为java的市场需求特别大，更加容易上岸一点。 在元神，亚秋，yp等同学的帮助下，学习了一年半，也算是成功上岸。从一个外包公司，到科大讯飞，到快手，再到阿里，一步一个台阶最后秋招终于拿下数个大厂offer。 春招： ​ 阿里，腾讯音乐，快手，招行信用卡中心 秋招（已经hr或者oc或者意向书）： ​ 阿里（已hr），腾讯，字节跳动，快手，百度，网易，京东，滴滴，shopee，大疆，猿辅导 转行之路在没开始面试前，我是从来不敢想自己能进入大厂的，一开始的目标只是进一个三线互联网或者硬件公司，只能说闷头只管努力，当你抬起头来的时候发现自己已经到了曾经不敢想的地方。 去年4月开始，认识到科研做不下去的时候，就准备开始转程序员。我选择了当下最热门的人工智能开始学习（再一次盲目跟风），瞎学了一个月python，深度学习，tensorflow，感觉就是闭门造车，东学一下，西学一下，完全找不到方向，而且毫无成就感，也不知道在做什么方向。直到认识了亚秋同学（亚秋同学就职于自动驾驶独角兽-小马智行），亚秋告诉我，我这样学算法，明年找工作只能成为失业大军中的一员，给我讲了很多算法的现状，什么诸神黄昏，天地寂灭等。告诉我及时换方向，虽然有点不舍，但是这个时候我已经明白了及时止损的道理，于是放弃了一个月的算法学习，开始走java后端的路线(这个时候是5月15)。 JAVA学习过程第一阶段：Java基础（菜鸟教程），mysql基础，servlet，spring框架，mybatis框架，springmvc框架 第一阶段就冲的很快，完全不理解原理，只知道照写代码，甚至觉得短短一两个月学这么多感觉计算机也不是那么难（太年轻==）。学了点java，html，sql语法就急于找一个实习证明自己，于是去学校旁边的一家外包公司面试，面试啥都不会。问我JAVA的三大特性我都不知道，当时就感觉自己忽略了很多细节，在外包公司干了几天，啥都不会，代码也看不懂。于是就辞职了，当时有个小哥告诉我，去学一下spring。（这个时候应该是6月底） 于是就一头扎进了ssm的学习，用了how2j的学习教程照着学一遍，似懂非懂，又照着w3school学一遍还是似懂非懂，后来在b站看的黑马视频课程，总算是大概明白了ssm怎么操作和基本原理。当时趁着，暑假出去玩了一趟，这个时候已经8月中旬了，在boss直聘上收到来自科大讯飞的一条消息，问我愿不愿意去实习，随后就去参加了面试，这个时候已经能答出来一点基础东西了，包括synchronized的用法，事务的ACID这些，答得一般般，可能看到我是中科大，还是让我过了面试。 第二阶段：springboot，springcloud， redis（中间穿插着阅读了JVM和并发编程的艺术）真正入职科大讯飞得时候，已经是9月初了，这个时候已经能开发点基本的网页了，在讯飞做的也就是这个事情，做了一些基本的CRUD。这个时间段是比较辛苦的一个时间段，因为讯飞离中科大是12公里，所以我早上6点多起床，然后坐车一个多小时到公司上班，晚上下班七点多到学校还没吃饭，有时候晚上回来还要做点实验。不过辛苦总会有回报，这个时间段，我认识了一个重要的同学，正元同学（目前就职于拼多多），在这之后，我终于不再是闭门造车，有人给我讲就业行情，有人给我讲大厂招聘消息，有人帮我改简历。元神给我提供了很多有用的资料，还教我如何去描述项目，并且让我少走了很多弯路，也是在他的建议下，我在讯飞实习期间自己实现了一个分布式锁，算是讯飞实习项目中为数不多的点之一了 == 。 springcloud，zookeeper，rabbitMQ11月底十二月初，快三个月了，我就从讯飞离职，学了点中间件，准备自己做一个项目（当时不知道做什么，后面发现同学没做的都是rpc等），我从网上找了一个十次方的项目，是一个微服务项目，用的技术栈是，springboot，springcloud，rabbitmq，redis等，之后我再自己加入了一个秒杀微服务（后来才知道秒杀项目烂大街），这也成为了我春招能吹的一些微服务，分布式的一些东西。不过后面事实证明，这种项目漏洞还是很多，幸运的是面试官都没有深究。 第三阶段：基础阶段，也是java的同学的面试重点基础课：操作系统，网络，数据结构元旦过后（1月1日），就开始背背书，搞搞学校的事情，一月底就回家了，刚好疫情爆发。就在家背背书（后面才觉得我这个学习方法是错误的，基础应该放在前面学习），主要内容是这些： 123456789101112131415Java基础：缓冲池，String，hashcode和equals，抽象类和接口，static，final，多态；集合：ArrayList， LinkedList，HashMap，HashSet，ConcurrentHashMap，CopyOnWriteArrayList，Queue，PrriorityQueueJVM：JVM内存区域，垃圾收集算法，垃圾收集器，类加载机制，JVM调优多线程：Synchronized,volatile, CAS,ReentrantLock,Countdownlatch, SemaphoreMysql：B+树索引，存储引擎的区别，覆盖索引，联合索引，最左匹配原则，三大范式，四大隔离级别，MVCC，锁Redis：优点，单线程，事件模型，持久化，主从复制，redis集群，缓存一致性，键删除策略，淘汰策略，分布式锁，缓存击穿，缓存雪崩，缓存无底洞Zookeeper： zab协议（加分），结构模型，功能和优点，分布式锁分布式相关：CAP，BASE，Paxos,分布式事务解决方案，ZAB，分布式锁，消息队列 当然，还没完全复习完的时候，春招就开始了 第四阶段： 源码阶段 + 面经阶段：因为一开始就没想着去大厂实习（导师不可能同样），听说阿里可以直通车，2月底，投了阿里巴巴试试，也没打算过，就想着练习练习，结果很顺利的面的两个部门通过了，当时想多试试，又投了腾讯和招行信用卡，结果都过了，当时是出乎我意料之外的。当时我是第一批拿到意向书的人，拿到阿里意向书的时候，那天晚上高兴的没怎么睡着。因为听说阿里流程很慢，要很久才能入职，于是投了个流程快的快手，还可以在家远程实习，所以我的4-6月就在快手实习了，之后又去了阿里实习一阵，后续秋招开启就没什么太多惊喜的了，因为无非就是重复春招的流程，很幸运的时候，面过的公司都拿到了offer。那么在这半年面试期间，其实也是穿插有一个学习和复习的过程的，主要是针对源码和面经主要如下： 12345678910111213需要了解的源码： 集合：ArrayList， LinkedList，HashMap，HashSet，ConcurrentHashMap，CopyOnWriteArrayList，Queue，PrriorityQueue AQS：AQS的原理，ReentrantLock，Countdownlatch, Semaphore 线程池的源码 Spring源码：初始化流程，循环依赖上面只是一些常问的源码，一些更细节的就不提出来了。包括春秋招期间跟同学们讨论的很多面经细节知识。当然算法的话，应该是整个学习过程中都要刷的，一般leecode 前200+剑指就够用，但是运气不好也有几率碰到难点的算法题，比如手撕跳表，比如手撕前缀树等。 总之~，感谢这一年的自己，可能比不上很多速成的大佬，不过还是很满意了，尤其是在毫无计算机基础还要跟导师斗智斗勇的基础上…，也希望大家都能够得偿所愿，不负坚持","categories":[{"name":"life","slug":"life","permalink":"https://www.yusp-spin.github.io/categories/life/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"博客成立啦","slug":"第一篇文章","date":"2020-09-13T05:24:50.000Z","updated":"2020-09-15T10:24:01.186Z","comments":true,"path":"2020/09/13/第一篇文章/","link":"","permalink":"https://www.yusp-spin.github.io/2020/09/13/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"想说的很多，以后都在这里记录，感谢~","categories":[{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/tags/%E6%97%A5%E5%B8%B8/"}]}],"categories":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/categories/Netty/"},{"name":"同步","slug":"同步","permalink":"https://www.yusp-spin.github.io/categories/%E5%90%8C%E6%AD%A5/"},{"name":"消息队列","slug":"消息队列","permalink":"https://www.yusp-spin.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"数据库","slug":"数据库","permalink":"https://www.yusp-spin.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"算法","slug":"算法","permalink":"https://www.yusp-spin.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"框架","slug":"框架","permalink":"https://www.yusp-spin.github.io/categories/%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.yusp-spin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"SpringBoot 框架","slug":"SpringBoot-框架","permalink":"https://www.yusp-spin.github.io/categories/SpringBoot-%E6%A1%86%E6%9E%B6/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.yusp-spin.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.yusp-spin.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Git","slug":"Git","permalink":"https://www.yusp-spin.github.io/categories/Git/"},{"name":"Go基础","slug":"Go基础","permalink":"https://www.yusp-spin.github.io/categories/Go%E5%9F%BA%E7%A1%80/"},{"name":"并发编程（go）","slug":"并发编程（go）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88go%EF%BC%89/"},{"name":"Gin框架","slug":"Gin框架","permalink":"https://www.yusp-spin.github.io/categories/Gin%E6%A1%86%E6%9E%B6/"},{"name":"life","slug":"life","permalink":"https://www.yusp-spin.github.io/categories/life/"},{"name":"IO","slug":"IO","permalink":"https://www.yusp-spin.github.io/categories/IO/"},{"name":"并发编程（java）","slug":"并发编程（java）","permalink":"https://www.yusp-spin.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88java%EF%BC%89/"},{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://www.yusp-spin.github.io/tags/Netty/"},{"name":"Redis","slug":"Redis","permalink":"https://www.yusp-spin.github.io/tags/Redis/"},{"name":"TopK","slug":"TopK","permalink":"https://www.yusp-spin.github.io/tags/TopK/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.yusp-spin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Goroutine","slug":"Goroutine","permalink":"https://www.yusp-spin.github.io/tags/Goroutine/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://www.yusp-spin.github.io/tags/%E5%89%91%E6%8C%87offer/"},{"name":"线程","slug":"线程","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"日常","slug":"日常","permalink":"https://www.yusp-spin.github.io/tags/%E6%97%A5%E5%B8%B8/"},{"name":"进程","slug":"进程","permalink":"https://www.yusp-spin.github.io/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"零拷贝","slug":"零拷贝","permalink":"https://www.yusp-spin.github.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D/"},{"name":"KMP","slug":"KMP","permalink":"https://www.yusp-spin.github.io/tags/KMP/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.yusp-spin.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"线程池","slug":"线程池","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"线程封闭","slug":"线程封闭","permalink":"https://www.yusp-spin.github.io/tags/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"},{"name":"并发","slug":"并发","permalink":"https://www.yusp-spin.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"背包","slug":"背包","permalink":"https://www.yusp-spin.github.io/tags/%E8%83%8C%E5%8C%85/"},{"name":"面经","slug":"面经","permalink":"https://www.yusp-spin.github.io/tags/%E9%9D%A2%E7%BB%8F/"}]}